<!DOCTYPE html>

<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.w3.org/1999/xhtml ../schema/htmlbook.xsd"
xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Études for Erlang</title>
    <meta name="Études for Erlang" content="text/html; charset=utf-8"/>
  </head>
<body class="book" data-type="book">
  <h1>Études for Erlang</h1>
  <figure data-type="cover">
    <img src="cover.png"/>
  </figure>
  <section data-type="titlepage">
    <h1>Études for Erlang</h1>
    
  </section>
  <section data-type="copyright-page">
    <h1>Études for Erlang</h1>
    
  </section>

<nav data-type="toc" class="toc" id="toc">
<h1>Table of Contents</h1>
<ol style="list-style-type:none">
<li><a href="#__tudes_for_erlang">Études for Erlang</a>
<ol style="list-style-type:none">
<li><a href="#_contributor_guidelines">Contributor Guidelines</a></li>
<li><a href="#_how_to_contribute">How to Contribute</a></li>
</ol>
</li>
<li><a href="#PREFACE">Preface: What&#8217;s an étude?</a>
<ol style="list-style-type:none">
<li><a href="#_what_are_tudes_for_erlang">What are Études for Erlang?</a></li>
<li><a href="#_how_this_book_was_written">How This Book was Written</a></li>
<li><a href="#_working_with_other_books">Working with Other Books</a></li>
<li><a href="#_acknowledgments">Acknowledgments</a></li>
</ol>
</li>
<li><a href="#GETTINGCOMFORTABLE">Getting Comfortable with Erlang</a>
<ol style="list-style-type:none">
<li><a href="#CH01-ET01">Étude 1-1: Experimenting with Errors</a></li>
</ol>
</li>
<li><a href="#FUNCTIONSMODULES">Functions and Modules</a>
<ol style="list-style-type:none">
<li><a href="#CH02-ET01">Étude 2-1: Writing a Function</a></li>
<li><a href="#CH02-ET02">Étude 2-2: Documenting a Module</a></li>
<li><a href="#CH02-ET03">Étude 2-3: Documenting a Function</a></li>
</ol>
</li>
<li><a href="#ATOMS-TUPLES-PATTERNS">Atoms, Tuples, and Pattern Matching</a>
<ol style="list-style-type:none">
<li><a href="#CH03-ET01">Étude 3-1: Pattern Matching</a></li>
<li><a href="#CH03-ET02">Étude 3-2: Guards</a></li>
<li><a href="#CH03-ET03">Étude 3-3: Underscores</a></li>
<li><a href="#CH03-ET04">Étude 3-4: Tuples as Parameters</a></li>
</ol>
</li>
<li><a href="#LOGIC-RECURSION">Logic and Recursion</a>
<ol style="list-style-type:none">
<li><a href="#CH04-ET01">Étude 4-1: Using <code>case</code></a></li>
<li><a href="#CH04-ET02">Étude 4-2: Recursion</a></li>
<li><a href="#CH04-ET03">Étude 4-3: Non-Tail Recursive Functions</a></li>
<li><a href="#CH04-ET04">Étude 4-4: Tail Recursion with an Accumulator</a></li>
<li><a href="#CH04-ET05">Étude 4-5: Recursion with a Helper Function</a></li>
</ol>
</li>
<li><a href="#STRINGS">Strings</a>
<ol style="list-style-type:none">
<li><a href="#CH05-ET01">Étude 5-1: Validating Input</a></li>
<li><a href="#CH05-ET02">Étude 5-2: Using the <code>re</code> Module</a></li>
</ol>
</li>
<li><a href="#LISTS">Lists</a>
<ol style="list-style-type:none">
<li><a href="#CH06-ET01">Étude 6-1: Recursive Iteration through a List</a></li>
<li><a href="#CH06-ET02">Étude 6-2: Iteration through Lists (More Practice)</a></li>
<li><a href="#CH06-ET03">Étude 6-3: Accumulating the Sum of a List</a></li>
<li><a href="#CH06-INTERLUDE">Interlude: "Mistakes were made."</a></li>
<li><a href="#CH06-ET04">Étude 6-4: Lists of Lists</a></li>
<li><a href="#CH06-ET05">Étude 6-5: Random Numbers; Generating Lists of Lists</a></li>
</ol>
</li>
<li><a href="#HIGHER-ORDER_FNS">Higher Order Functions and List Comprehensions</a>
<ol style="list-style-type:none">
<li><a href="#CH07-ET01">Étude 7-1: Simple Higher Order Functions</a></li>
<li><a href="#CH07-ET02">Étude 7-2: List Comprehensions and Pattern Matching</a></li>
<li><a href="#CH07-ET03">Étude 7-3: Using <code>lists:foldl/3</code></a></li>
<li><a href="#CH07-ET04">Étude 7-4: Using <code>lists:split/2</code></a></li>
<li><a href="#CH07-ET05">Étude 7-5: Multiple Generators in List Comprehensions</a></li>
<li><a href="#CH07-ET06">Étude 7-6: Explaining an Algorithm</a></li>
</ol>
</li>
<li><a href="#PROCESSES">Processes</a>
<ol style="list-style-type:none">
<li><a href="#CH08-ET01">Étude 8-1: Using Processes to Simulate a Card Game</a></li>
</ol>
</li>
<li><a href="#HANDLING_ERRORS">Handling Errors</a>
<ol style="list-style-type:none">
<li><a href="#CH09-ET01">Étude 9-1: <code>try</code> and <code>catch</code></a></li>
<li><a href="#CH09-ET02">Étude 9-2: Logging Errors</a></li>
</ol>
</li>
<li><a href="#STORING-STRUCTURED-DATA">Storing Structured Data</a>
<ol style="list-style-type:none">
<li><a href="#CH10-ET01">Étude 10-1: Using ETS</a></li>
<li><a href="#CH10-ET02">Étude 10-2: Using Mnesia</a></li>
</ol>
</li>
<li><a href="#OTP">Getting Started with OTP</a>
<ol style="list-style-type:none">
<li><a href="#CH11-ET01">Étude 11-1: Get the Weather</a></li>
<li><a href="#CH11-ET02">Étude 11-2: Wrapper Functions</a></li>
<li><a href="#CH11-ET03">Étude 11-3: Independent Server and Client</a></li>
<li><a href="#CH11-ET04">Étude 11-4: Chat Room</a></li>
</ol>
</li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#APPENDIX">Appendix A: Solutions to Études</a>
<ol style="list-style-type:none">
<li><a href="#SOLUTION02-ET01">Solution 2-1</a></li>
<li><a href="#SOLUTION02-ET02">Solution 2-2</a></li>
<li><a href="#SOLUTION02-ET03">Solution 2-3</a></li>
<li><a href="#SOLUTION03-ET01">Solution 3-1</a></li>
<li><a href="#SOLUTION03-ET02">Solution 3-2</a></li>
<li><a href="#SOLUTION03-ET03">Solution 3-3</a></li>
<li><a href="#SOLUTION03-ET04">Solution 3-4</a></li>
<li><a href="#SOLUTION04-ET01">Solution 4-1</a></li>
<li><a href="#SOLUTION04-ET02">Solution 4-2</a></li>
<li><a href="#SOLUTION04-ET02B">Solution 4-2</a></li>
<li><a href="#SOLUTION04-ET03">Solution 4-3</a></li>
<li><a href="#SOLUTION04-ET04">Solution 4-4</a></li>
<li><a href="#SOLUTION04-ET05">Solution 4-5</a></li>
<li><a href="#SOLUTION05-ET01">Solution 5-1</a></li>
<li><a href="#SOLUTION05-ET02">Solution 5-2</a></li>
<li><a href="#SOLUTION06-ET01">Solution 6-1</a></li>
<li><a href="#SOLUTION06-ET02">Solution 6-2</a></li>
<li><a href="#SOLUTION06-ET03">Solution 6-3</a></li>
<li><a href="#SOLUTION06-ET04">Solution 6-4</a></li>
<li><a href="#SOLUTION06-ET05">Solution 6-5</a></li>
<li><a href="#SOLUTION07-ET01">Solution 7-1</a></li>
<li><a href="#SOLUTION07-ET02">Solution 7-2</a></li>
<li><a href="#SOLUTION07-ET03">Solution 7-3</a></li>
<li><a href="#SOLUTION07-ET04">Solution 7-4</a></li>
<li><a href="#SOLUTION07-ET05">Solution 7-5</a></li>
<li><a href="#SOLUTION07-ET06">Solution 7-6</a></li>
<li><a href="#SOLUTION08-ET01">Solution 8-1</a></li>
<li><a href="#SOLUTION09-ET01">Solution 9-1</a></li>
<li><a href="#SOLUTION09-ET02">Solution 9-2</a></li>
<li><a href="#SOLUTION10-ET01">Solution 10-1</a></li>
<li><a href="#SOLUTION10-ET02">Solution 10-2</a></li>
<li><a href="#SOLUTION11-ET01">Solution 11-1</a></li>
<li><a href="#SOLUTION11-ET02">Solution 11-2</a></li>
<li><a href="#SOLUTION11-ET03">Solution 11-3</a></li>
<li><a href="#SOLUTION11-ET04">Solution 11-4</a></li>
</ol>
</li>
</ol></nav>


<section class="preface" data-type="preface" id="__tudes_for_erlang">
<h1>Études for Erlang</h1>
<p>Welcome to <em>Études for Erlang</em>.  In this book, you will find descriptions of programs that you can write in Erlang. The programs will usually be short, and each one has been designed to provide practice material for a particular Erlang programming concept. These programs have not been designed to be of considerable difficulty, though they may ask you to stretch a bit beyond the immediate material and examples that you find in the book <a href="http://shop.oreilly.com/product/0636920025818.do">Introducing Erlang</a>.</p>
<p>This book is open source, so if you&#8217;d like to contribute, make a correction, or otherwise participate in the project, check out <a href="https://github.com/oreillymedia/etudes-for-erlang">oreillymedia/etudes-for-erlang</a> on GitHub for details. If we accept your work, we&#8217;ll add you to the contributors chapter.</p>
<p>The online version of the book is at <a href="http://chimera.labs.oreilly.com/books/1234000000726">Études for Erlang</a> on O&#8217;Reilly Labs.</p>



<section class="sect1" data-type="sect1" id="_contributor_guidelines">
<h1>Contributor Guidelines</h1>
<p>If you&#8217;re considering making a contribution, here are some guidelines to keep in mind:</p>

<dl>
<dt>Creative Commons license.</dt>
<dd><p>All contributions made to this site are required to be made under the <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>. This means that by making a content contribution, you are agreeing that it is licensed to us and to others under this license. If you do not want your content to be available under this license, you should not contribute it.</p></dd>
<dt>Submit only your own work.</dt>
<dd><p>You warrant that all work that you contribute to this site is your original work, except for material that is in the public domain or for which you have obtained permission. Feel free to draw from your own existing work (blogs, articles, talks, etc.), so long as you are happy with the Creative Commons license.</p></dd>
<dt>Your submission may not be accepted.</dt>
<dd><p>Be aware that we may not be able to accept your contribution.</p></dd>
<dt>Keep your title pithy and to the point.</dt>
<dd><p>The title should only be a 2 to 10 words long if possible and should summarize or capture the essence of the advice. Keep your discussion between 400 and 500 words.</p></dd>
<dt>Volunteers only.</dt>
<dd><p>Contributions are made on a volunteer basis — in other words, contributors are not paid for their contributions. The contributions will be made easily available to everyone on the Web for free. However, remember that those of you whose contributions are chosen for publication will get your name attached to your work and your bio published next to it. Any item you contribute you can also reuse in any form you wish, such as in a blog posting.</p></dd>
<dt>Only submit a pull request when you consider your work complete.</dt>
<dd><p>Please submit your work once it is complete.  Once you make a pull request, the editor will review the submission and (possibly) suggest some changes.  Reducing work in progress makes it easier for you to see your own progress and for others to see the progress of the whole project.</p></dd>
<dt>Check spelling, word count, and formatting.</dt>
<dd><p>Such checking seems obvious part, but it is worth a reminder — sometimes it seems that it is honored more in the breach than in the observance. US spelling is used for the contributions, which should be between 400 and 500 words in length. Formatting can be checked by looking at the saved page in GitHub.  If it looks right there, it&#8217;s probably right.</p></dd>
</dl>
</section>






<section class="sect1" data-type="sect1" id="_how_to_contribute">
<h1>How to Contribute</h1>
<p>If you&#8217;re new to git and GitHub and just want to keep things as simple as possible, this tutorial will give you a quick and easy way to make your contribution.  Here are the steps you&#8217;ll need to follow:</p>




<section class="sect2" data-type="sect2" id="_create_a_github_account">
<h2>Create a GitHub account</h2>
<p>To create and edit a page or to comment on an existing page, you will need to create an account on GitHub. If you don&#8217;t have one already, then go to the <a href="https://github.com/signup/free">GitHub Signup page</a>. It&#8217;s free.</p>
<figure>

<figcaption/>
<img src="images/tutorial_github_signup.png" alt="tutorial github signup"/>
</figure>
<p>GitHub has excellent tools for collaborating and workflow management, and will be the primary way we communicate with you over the course of the project.</p>
</section>






<section class="sect2" data-type="sect2" id="_copy_fork_the_project_repository_to_your_account">
<h2>Copy ("fork") the project repository to your account</h2>
<p>Once you&#8217;ve got an account, fork (GitHub lingo for copying) the main project to your account.  To do this, go to the  <a href="https://github.com/oreillymedia/etudes-for-erlang">Etudes for Erlang</a> repository on GitHub and click the "Fork" button at the upper right hand side of the screen.</p>
<figure>

<figcaption/>
<img src="images/tutorial_click_fork.png" alt="tutorial click fork"/>
</figure>
<p>The following screen will appear while GitHub copies the repository to your account:</p>
<figure>

<figcaption/>
<img src="images/tutorial_forking.png" alt="tutorial forking"/>
</figure>
</section>






<section class="sect2" data-type="sect2" id="_edit_your_file_using_asciidoc">
<h2>Edit your file using AsciiDoc</h2>
<p>Once you&#8217;ve got the file created, you can start editing it at your leisure.  Remember to:</p>
<ul>
<li><p>Mark up your text using <a href="http://powerman.name/doc/asciidoc">AsciiDoc</a>, which is similar to Markdown and other basic wiki-like markup formats.</p></li>
<li><p>Change the line wrapping from "No Wrap" to "Soft Wrap."  Otherwise, all your text will appear on a single line.</p></li>
</ul>
<p>To edit the file, all you have to do is click its name in the directory listing in GitHub and then press the "Edit" button.</p>
<figure>

<figcaption/>
<img src="images/tutorial_edit.png" alt="tutorial edit"/>
</figure>
<div data-type="note" class="note">
<p>If you want to add an entirely new topic area, you&#8217;ll need to create a new file in GitHub.  To do this, click the "+" button next to the directory name to create a new file</p>
<p>Locate the small "+" sign next to the repository name.  (A tooltip will appear that says "Create a new file here" when you hover your mouse above it.)  Click the "\+" button:</p>
<figure>

<figcaption/>
<img src="images/tutorial_add_a_file.png" alt="tutorial add a file"/>
</figure>
<p>In the new screen, you&#8217;ll need to:</p>
<ul>
<li><p>Enter a name for the file.  Name the file according to the general topic area, and be sure to include the extension ".asciidoc" at the end.  For example, "foo_and_bar.asciidoc".</p></li>
<li><p>Enter the chapter title in the editing box; it should be prefaced with two "==" signs.  For example, "== Always Foo the Bar"</p></li>
<li><p>Once you&#8217;ve entered the filename and title, the "Commit Changes" button at the bottom of the screen will activate.  Click the button to save your file.</p></li>
</ul>
<p>You will see something like this:</p>
<figure>

<figcaption/>
<img src="images/tutorial_naming_a_file.png" alt="tutorial naming a file"/>
</figure>
</div>
</section>






<section class="sect2" data-type="sect2" id="_double_check_your_submission_and_add_your_biography">
<h2>Double check your submission and add your biography</h2>
<p>Before you submit your request, make sure that you have:</p>
<ul>
<li><p>Run a spell check</p></li>
<li><p>Make sure it&#8217;s 400-500 words in length</p></li>
<li><p>Add your name and a short biography</p></li>
<li><p>Check the formatting to make sure it looks OK</p></li>
</ul>
<p>Your biography should look like this:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="asciidoc">.About the Author
[NOTE]
****
Name::
   Nicola Tesla
Biography::
   Nicola Tesla is an inventor, electrical engineer, mechanical engineer, physicist, and futurist best known for his contributions to the design of the modern alternating current (AC) electrical supply system.
****</pre>
</section>






<section class="sect2" data-type="sect2" id="_submit_a_pull_request">
<h2>Submit a pull request</h2>
<p>Once you&#8217;ve completed and double checked your submission, you&#8217;re ready to submit it back to O&#8217;Reilly.  This is done by creating a "pull request" that will trigger the review process.</p>
<figure>

<figcaption/>
<img src="images/tutorial_submit_pull_request.png" alt="tutorial submit pull request"/>
</figure>
<p>When you submit the pull request, you&#8217;ll also be able to submit some additional information that will help us track your work:</p>
<ul>
<li><p>A title.  Please enter your name and the title of the contribution.  For example, "Andrew Odewahn: Always Foo the Bar"</p></li>
<li><p>A comment.  Tell us a little bit about your contribution, as well as anything else you think we should know.</p></li>
</ul>
<figure>

<figcaption/>
<img src="images/tutorial_pull_request_submission_form.png" alt="tutorial pull request submission form"/>
</figure>
</section>






<section class="sect2" data-type="sect2" id="_engage_in_back_and_forth">
<h2>Engage in back-and-forth</h2>
<p>Once you submit your pull request, the project&#8217;s maintainers will begin a back and forth with you in the discussion features.  You might be asked to make some revisions, shorten it, add additional elements, and so forth.</p>
</section>


</section>



</section>






<section class="preface" data-type="preface" id="PREFACE">
<h1>Preface: What&#8217;s an étude?</h1>
<p>An étude, according to Wikipedia, is "an instrumental musical composition, usually short and of considerable difficulty, usually designed to provide practice material for perfecting a particular musical skill."</p>



<section class="sect1" data-type="sect1" id="_what_are_tudes_for_erlang">
<h1>What are Études for Erlang?</h1>
<p>In this book, you will find descriptions of programs that you
can compose (write) in Erlang. The programs will usually be short,
and each one has been designed to provide practice material for a particular
Erlang programming concept. Unlike musical études, these programs have not been
designed to be of considerable difficulty, though they may ask you to
stretch a bit beyond the immediate material and examples that you find
in the book <a href="http://shop.oreilly.com/product/0636920025818.do">Introducing Erlang</a>.</p>
</section>






<section class="sect1" data-type="sect1" id="_how_this_book_was_written">
<h1>How This Book was Written</h1>
<p>While reading the early release version of <em>Introducing Erlang</em>,
I began by copying the examples in the book. (This always helps me
learn the material better.) I then began experimenting with small
programs of my own to make sure I really understood the concepts.
As I continued writing my own examples, I thought they might be useful
to other people as well. I contacted Simon St. Laurent, the author
of Introducing Erlang, and he liked the idea of having these companion
exercises and suggested naming them études.
At some point, the études took on a life of their own,
and you are reading the result now.</p>
<p>I was learning Erlang as I was creating the solutions to the
études, following the
philosophy that "the first way that works is the right way."
Therefore, don&#8217;t be surprised if you see some fairly
naïve code that an expert Erlang programmer would never write.</p>
</section>






<section class="sect1" data-type="sect1" id="_working_with_other_books">
<h1>Working with Other Books</h1>
<p>Although this was based on <em>Introducing Erlang</em>, you can use it with other Erlang books. A note at the beginning of each chapter will point you to relevant sections in other books. The books listed through are:</p>
<ul>
<li><p><a href="http://shop.oreilly.com/product/9780596518189.do">Erlang Programming</a>, by Francesco Cesarini, and Simon Thompson (O&#8217;Reilly Media, 2009).</p></li>
<li><p><a href="http://pragprog.com/book/jaerlang/programming-erlang">Programming Erlang</a>, by Joe Armstrong (Pragmatic Programmers, 2007).</p></li>
<li><p><a href="http://www.manning.com/logan/">Erlang and OTP in Action</a> by Martin Logan, Eric Merritt, and Richard Carlsson (Manning, 2010).</p></li>
<li><p><a href="http://nostarch.com/erlang">Learn You Some Erlang for Great Good!</a> by Fred Hebert (No Starch Press, 2013) - also available at <a href="http://learnyousomeerlang.com/">http://learnyousomeerlang.com/</a>.</p></li>
</ul>
</section>






<section class="sect1" data-type="sect1" id="_acknowledgments">
<h1>Acknowledgments</h1>
<p>Many thanks to Simon St. Laurent, who wrote <em>Introducing Erlang</em>. His book
not only got me to begin to understand functional programming, but also made
me realize that it was a lot of fun. Simon also felt that the exercises
I was writing for myself could be useful to others, and he encouraged me
to continue developing them.</p>
<aside id="suggested_topic" data-type="sidebar" class="sidebar shoutout">
<h5>Have any suggested topics?</h5>
<p>Suggest topics you&#8217;d like to see covered here, or just go add them yourself at <a href="https://github.com/oreillymedia/etudes-for-erlang">oreillymedia/etudes-for-erlang</a> on GitHub.</p>
</aside>
</section>



</section>






<section data-type="chapter" id="GETTINGCOMFORTABLE">
<h1>Getting Comfortable with Erlang</h1>
<div data-type="note" class="note">
You can learn more about working with <code>erl</code> in Chapter 2 of <em>Erlang Programming</em>, Chapters 2 and 6 of <em>Programming Erlang</em>, Section 2.1 of <em>Erlang and OTP in Action</em>, and Chapter 1 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH01-ET01">
<h1>Étude 1-1: Experimenting with Errors</h1>
<p>The first chapter of
<a href="http://shop.oreilly.com/product/0636920025818.do">Introducing Erlang</a>
encourages you to play around with the interactive <code>erl</code> system.
In this étude, keep using <code>erl</code>, but purposely make errors.</p>
<p>Try leaving out parentheses in arithmetic expressions. Try putting
numbers next to each other without an operator between them.
Try adding <code>"adam"</code> to <code>12</code>. Make up variable names that you are sure
Erlang wouldn&#8217;t ever accept.</p>
<p>That way, you&#8217;ll get a feel for the sort of error messages
Erlang produces and not be as baffled when you get errors that
you aren&#8217;t expecting.</p>
</section>



</section>






<section data-type="chapter" id="FUNCTIONSMODULES">
<h1>Functions and Modules</h1>
<div data-type="note" class="note">
You can learn more about working with functions and modules in Chapters 2, 3, and 9 of <em>Erlang Programming</em>, Chapter 3 of <em>Programming Erlang</em>, Sections 2.3, 2.5, and 2.7 of <em>Erlang and OTP in Action</em>, and Chapters 2 and 3 of <em>Learn You Some Erlang For Great Good!</em>.  There&#8217;s more on documentation in Chapter 18 of <em>Erlang Programming</em> and types in Chapter 30 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH02-ET01">
<h1>Étude 2-1: Writing a Function</h1>
<p>Write a module with a function that takes the length and width of a
rectangle and returns (yields) its area.  Name the module <code>geom</code>, and
name the function <code>area</code>. The function has arity 2, because it needs
two pieces of information to make the calculation. In Erlang-speak:
write function <code>area/2</code>.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">1&gt; c(geom).
{ok,geom}
2&gt; geom:area(3,4).
12
3&gt; geom:area(12,7).
84</pre>
<p><a data-type="xref" href="#SOLUTION02-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH02-ET02">
<h1>Étude 2-2: Documenting a Module</h1>
<p>Document the <code>geom</code> module you wrote in <a data-type="xref" href="#CH02-ET01">Étude 2-1</a>.
<a data-type="xref" href="#SOLUTION02-ET02">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH02-ET03">
<h1>Étude 2-3: Documenting a Function</h1>
<p>Document the <code>area/2</code> function, and create an <em>overview.edoc</em> file to complete
the documentation of the application you&#8217;ve written.
<a data-type="xref" href="#SOLUTION02-ET03">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="ATOMS-TUPLES-PATTERNS">
<h1>Atoms, Tuples, and Pattern Matching</h1>
<div data-type="note" class="note">
You can learn more about working with atoms, tuples, and pattern matching in Chapter 2 of <em>Erlang Programming</em>, Chapter 2 of <em>Programming Erlang</em>, Sections 2.2 and 2.4 of <em>Erlang and OTP in Action</em>, and Chapters 1 and 3 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH03-ET01">
<h1>Étude 3-1: Pattern Matching</h1>
<p>Use atoms and pattern matching to make your <code>area</code> function calculate the
area of a rectangle, triangle, or ellipse.  If your parameters are
<code>Shape</code>, <code>A</code> and <code>B</code>, the area for the atom <code>rectangle</code> is <code>A * B</code>,
where <code>A</code> and <code>B</code> represent the length and width. For a <code>triangle</code> atom,
the area is <code>A * B / 2.0</code>, with <code>A</code> and <code>B</code> representing
the base and height of the triangle. For an <code>ellipse</code> atom, the area is
<code>math:pi() * A * B</code>, where <code>A</code> and <code>B</code> represent the major and minor radiuses.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(geom).
{ok,geom}
2&gt; geom:area(rectangle, 3, 4).
12
3&gt; geom:area(triangle, 3, 5).
7.5
4&gt; geom:area(ellipse, 2, 4).
25.132741228718345</pre>
<p><a data-type="xref" href="#SOLUTION03-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH03-ET02">
<h1>Étude 3-2: Guards</h1>
<p>Even though you won&#8217;t get an error message when calculating the area of a shape
that has negative dimensions, it&#8217;s still worth guarding your <code>area/3</code> function.
You will want two guards for each pattern to make sure that both dimensions
are greater than or equal to zero. Since <strong>both</strong> have to be non-negative, use
commas to separate your guards.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(geom).
{ok,geom}
2&gt; geom:area(rectangle, 3, 4).
12
3&gt; geom:area(ellipse, 2, 3).
18.84955592153876
4&gt; geom:area(triangle, 4, 5).
10.0
5&gt; geom:area(rectangle, -1, 3).
** exception error: no function clause matching geom:area(rectangle,-1,3) (geom.erl, line 18)</pre>
<p><a data-type="xref" href="#SOLUTION03-ET02">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH03-ET03">
<h1>Étude 3-3: Underscores</h1>
<p>If you enter a shape that <code>area/3</code> doesn&#8217;t know about, or if you enter negative
dimensions, Erlang will give you an error message. Use underscores to create a
&#8220;catch-all&#8221; version, so that anything at all that doesn&#8217;t match a valid
rectangle, triangle, or ellipse will return zero. This goes against
the Erlang philosophy of &#8220;let it fail,&#8221; but let&#8217;s look the other way
and learn about underscores anyway.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; geom:area(rectangle, 3, 4).
12
2&gt; geom:area(pentagon, 3, 4).
0
3&gt; geom:area(hexagon, -1, 5).
0
4&gt; geom:area(rectangle, 1, -3).
0</pre>
<p><a data-type="xref" href="#SOLUTION03-ET03">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH03-ET04">
<h1>Étude 3-4: Tuples as Parameters</h1>
<p>Add an <code>area/1</code> function that takes a tuple of the form
<code>{<strong>shape</strong>,<strong>number</strong>,<strong>number</strong>}</code> as its parameter. Export it
instead of <code>area/3</code>. The <code>area/1</code> function will call the
private <code>area/3</code> function.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(geom).
{ok,geom}
2&gt; geom:area({rectangle, 7, 3}).
21
3&gt; geom:area({triangle, 7, 3}).
10.5
4&gt; geom:area({ellipse, 7, 3}).
65.97344572538566</pre>
<p><a data-type="xref" href="#SOLUTION03-ET04">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="LOGIC-RECURSION">
<h1>Logic and Recursion</h1>
<div data-type="note" class="note">
You can learn more about working with logical flow and recursion in Chapter 3 of <em>Erlang Programming</em>, Chapter 3 of <em>Programming Erlang</em>, Sections 2.6 and 2.15 of <em>Erlang and OTP in Action</em>, and Chapters 3 and 5 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH04-ET01">
<h1>Étude 4-1: Using <code>case</code></h1>
<p>Change the <code>area/3</code> function that you wrote in
<a data-type="xref" href="#CH03-ET02">Étude 3-2</a> so that it uses a <code>case</code> instead
of pattern matching. Use a guard on the function definition to ensure
that the numeric arguments are both greater than zero.</p>
<p><a data-type="xref" href="#SOLUTION04-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH04-ET02">
<h1>Étude 4-2: Recursion</h1>
<p>This is a typical exercise for recursion: finding the greatest common
divisor (GCD) of two integers. Instead of giving Euclid&#8217;s method, we&#8217;ll
do this with a method devised by Edsger W. Dijkstra. The neat part about
Dijkstra&#8217;s method is that you don&#8217;t need to do any division to find
the result.  Here is the method.</p>
<p>To find the GCD of integers M and N:</p>
<ul>
<li><p>If M and N are equal, the result is M.</p></li>
<li><p>If M is greater than N, the result is the GCD of M - N and N</p></li>
<li><p>Otherwise M must be less than N, and the result is the GCD of M and N - M.</p></li>
</ul>
<p>Write a function <code>gcd/2</code> in a module named <code>dijkstra</code> that implements
the algorithm. This program is an ideal place to practice Erlang&#8217;s <code>if</code> construct.
Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(dijkstra).
{ok,dijkstra}
2&gt; dijkstra:gcd(12, 8).
4
3&gt; dijkstra:gcd(14, 21).
7
4&gt; dijkstra:gcd(125, 46).
1
5&gt; dijkstra:gcd(120, 36).
12</pre>
<p><a data-type="xref" href="#SOLUTION04-ET02">See a suggested solution in Appendix A.</a></p>
<p>You can also use guards with multiple clauses to solve this étude; <a data-type="xref" href="#SOLUTION04-ET02B">the solution for that approach is in Appendix A.</a> In general, use of guards is considered more in the spirit of Erlang.</p>
<p>The next two exercises involve writing code to raise a number to an integer
power (like 2.5<sup>3</sup> or 4<sup>-2</sup>) and finding the <em>n</em>th root of a number, such
as the cube root of 1728 or the fifth root of 3.2.</p>
<p>These capabilities already exist with the <code>math:pow/2</code> function, so you may
wonder why I&#8217;m asking you to re-invent the wheel. The reason is not to replace
<code>math:pow/2</code>, but to experiment with recursion by writing functions that can be
expressed quite nicely that way.</p>
</section>






<section class="sect1" data-type="sect1" id="CH04-ET03">
<h1>Étude 4-3: Non-Tail Recursive Functions</h1>
<p>Create a module named <code>powers</code> (no relation to Francis Gary Powers), and
write a function named <code>raise/2</code> which takes parameters <code>X</code>  and <code>N</code> and
returns the value of X<sup>N</sup>.</p>
<p>Here&#8217;s the information you need to know to write the function:</p>
<ul>
<li><p>Any number to the power 0 equals 1.</p></li>
<li><p>Any number to the power 1 is that number itself&#8201;&#8212;&#8201;that stops the
recursion.</p></li>
<li><p>When <code>N</code> is positive, <code>X<sup>N</sup></code> is equal to <code>X</code> times <code>X<sup>(N - 1)</sup></code>&#8201;&#8212;&#8201;there&#8217;s your recursion.</p></li>
<li><p>When <code>N</code> is negative, <code>X<sup>N</sup></code> is equal to <code>1.0 / X<sup>-N</sup></code></p></li>
</ul>
<p>Note that this function is <em>not</em> tail recursive.  Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(powers).
{ok,powers}
2&gt; powers:raise(5, 1).
5
3&gt; powers:raise(2, 3).
8
4&gt; powers:raise(1.2, 3).
1.728
5&gt; powers:raise(2, 0).
1
6&gt; powers:raise(2, -3).
0.125</pre>
<p><a data-type="xref" href="#SOLUTION04-ET03">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH04-ET04">
<h1>Étude 4-4: Tail Recursion with an Accumulator</h1>
<p>Practice the "accumulator trick."
Rewrite the <code>raise/2</code> function for <code>N</code> greater than zero so that it
calls a helper function <code>raise/3</code>  This new function has <code>X</code>, <code>N</code>, and
an <code>Accumulator</code> as its parameters.</p>
<p>Your <code>raise/2</code> function will return 1 when <code>N</code> is equal to 0,
and will return <code>1.0 / raise(X, -N)</code> when N is less than zero.</p>
<p>When <code>N</code> is greater than zero, <code>raise/2</code> will
call <code>raise/3</code> with arguments <code>X</code>, <code>N</code>, and 1 as the Accumulator.</p>
<p>The <code>raise/3</code> function will return the
<code>Accumulator</code> when <code>N</code> equals 0 (this will stop the recursion).</p>
<p>Otherwise, recursively call <code>raise/3</code> with <code>X</code>, <code>N - 1</code>,
and <code>X</code> times the <code>Accumulator</code> as its arguments.</p>
<p>The <code>raise/3</code> function <em>is</em> tail recursive.</p>
</section>






<section class="sect1" data-type="sect1" id="CH04-ET05">
<h1>Étude 4-5: Recursion with a Helper Function</h1>
<p>In this exercise, you will add a function <code>nth_root/2</code> to the
<code>powers</code> module. This new function finds the
<em>n</em>th root of a number, where <em>n</em> is an integer.
For example, <code>nth_root(36, 2)</code> will calculate
the square root of 36, and <code>nth_root(1.728, 3)</code> will return the cube
root of 1.728.</p>
<p>The algorithm used here is the Newton-Raphson method for calculating
roots. (See <a href="http://en.wikipedia.org/wiki/Newton%27s_method">http://en.wikipedia.org/wiki/Newton%27s_method</a> for details).</p>
<p>You will need a helper function <code>nth_root/3</code>, whose parameters
are <code>X</code>, <code>N</code>, and an approximation to the result, which we
will call <code>A</code>. <code>nth_root/3</code> works as follows:</p>
<ul>
<li><p>Calculate <code>F</code> as <code>(A<sup>N</sup> - X)</code></p></li>
<li><p>Calculate <code>Fprime</code> as <code>N * A<sup>(N - 1)</sup></code></p></li>
<li><p>Calculate your next approximation (call it <code>Next</code>) as <code>A - F / Fprime</code></p></li>
<li><p>Calculate the change in value (call it <code>Change</code>) as the absolute value of <code>Next - A</code></p></li>
<li><p>If the <code>Change</code> is
less than some limit (say, 1.0e-8), stop the recursion and return
<code>Next</code>; that&#8217;s as close to the root as you are going to get.</p></li>
<li><p>Otherwise, call the <code>nth_root/3</code> function again with
<code>X</code>, <code>N</code>, and <code>Next</code> as its arguments.</p></li>
</ul>
<p>For your first approximation, use <code>X / 2.0</code>. Thus, your <code>nth_root/2</code> function
will simply be this:</p>
<p><code>nth_root(X, N) &#8594; nth_root(X, N, X / 2.0)</code></p>
<p>Use <code>io:format</code> to show each new approximation as you
calculate it. Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(powers).
{ok,powers}
2&gt; powers:nth_root(27, 3).
Current guess is 13.5
Current guess is 9.049382716049383
Current guess is 6.142823558176272
Current guess is 4.333725614685509
Current guess is 3.3683535855517652
Current guess is 3.038813723595138
Current guess is 3.0004936436555805
Current guess is 3.000000081210202
Current guess is 3.000000000000002
3.0</pre>
<p><a data-type="xref" href="#SOLUTION04-ET05">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="STRINGS">
<h1>Strings</h1>
<div data-type="note" class="note">
You can learn more about working with strings in Chapter 2 of <em>Erlang Programming</em>, Sections 2.11 and 5.4 of <em>Programming Erlang</em>, Section 2.2.6 of <em>Erlang and OTP in Action</em>, and Chapter 1 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH05-ET01">
<h1>Étude 5-1: Validating Input</h1>
<p>The Erlang philosophy is "let it crash"; this makes a great deal of sense
for a telecommunications system (which is what Erlang was first designed for).
Hardware is going to fail. When it does, you just replace it or restart it.
The person using the phone system is unaware of this; her phone just
continues to work.</p>
<p>This philosophy, however, is not the one you want to employ when you
have (atypical for Erlang) programs that ask for user input.
You want to those to crash infrequently and catch as many input errors as possible.</p>
<p>In this étude, you will write a module named <code>ask_area</code>, which prompts you
for a shape and its dimensions, and then returns the area by calling
<code>geom:area/3</code>, which you wrote in <a data-type="xref" href="#CH04-ET01">Étude 4-1</a>.</p>
<p>Your module will ask for the first letter of the shape (in either upper
or lower case), then the appropriate dimensions. It should catch invalid
letters, non-numeric input, and negative numbers as input.
Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(ask_area).
{ok,ask_area}
2&gt; c(geom).
{ok,geom}
3&gt; ask_area:area().
R)ectangle, T)riangle, or E)llipse &gt; r
Enter width &gt; 4
Enter height &gt; 3.7
14.8
4&gt; ask_area:area().
R)ectangle, T)riangle, or E)llipse &gt; T
Enter base &gt; 3
Enter height &gt; 7
10.5
5&gt; ask_area:area().
R)ectangle, T)riangle, or E)llipse &gt; x
Unknown shape x
ok
6&gt; ask_area:area().
R)ectangle, T)riangle, or E)llipse &gt; r
Enter width &gt; -3
Enter height &gt; 4
Both numbers must be greater than or equal to zero.
ok
7&gt; ask_area:area().
R)ectangle, T)riangle, or E)llipse &gt; e
Enter major axis &gt; three
Enter minor axis &gt; 2
Error in first number.</pre>
<p>Here are the functions that I needed to write in order to make this
program work.</p>

<dl>
<dt><code>char_to_shape/1</code></dt>
<dd><p>Given a character parameter (<code>R</code>, <code>T</code>, or <code>E</code> in either upper or lower case),
return an atom representing the specified shape (<code>rectangle</code>,
<code>triangle</code>, <code>ellipse</code>, or <code>unknown</code> if some other character is entered).</p></dd>
<dt><code>get_number/1</code></dt>
<dd><p>Given a string as a prompt, displays the string
<code>"Enter <em>prompt</em> &gt; "</code> and returns the number that was input.
Your function should accept either integers or floats. Fun fact:
<code>string:to_float/1</code> <em>requires</em> a decimal point; if you just enter
input like <code>"3"</code>, you will receive <code>{error,no_float}</code> for your efforts.
That means that you should try to convert to float first,
and if that fails, try a conversion to integer.
It was at this point that I felt like the
guy who is beating his head against a wall, and, when asked, "Why are you
doing that?" responds, "Because it feels so good when I stop."</p></dd>
<dt><code>get_dimensions/2</code></dt>
<dd><p>Takes two prompts as its parameters (one for each dimension), and calls
<code>get_number/1</code> twice. Returns a tuple <code>{<em>N1</em>, <em>N2</em>}</code> with the dimensions.</p></dd>
<dt><code>calculate/3</code></dt>
<dd><p>Takes a shape (as an atom) and two dimensions as its parameters.
If the shape is <code>unknown</code>, or the first or second dimension isn&#8217;t numeric,
or either number is negative, the function displays an
appropriate error message. Otherwise, the function calls
<code>geom:area/3</code> to calculate the area of the shape.</p></dd>
</dl>
<p><a data-type="xref" href="#SOLUTION05-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH05-ET02">
<h1>Étude 5-2: Using the <code>re</code> Module</h1>
<p>Write a module named <code>dates</code> that contains a function
<code>date_parts/1</code>, which takes a string in ISO date format
(<code>"yyyy-mm-dd"</code>) and
returns a list of integers in the form
<code>[yyyy, mm, dd]</code>. This function does not need to do any error checking.</p>
<p>You&#8217;ll use the <code>re:split/3</code> function from Erlang&#8217;s
regular expression (<code>re</code>) module to accomplish the task.
How, you may ask, does that function work? Ask Erlang!
The command <code>erl -man re</code> will give you the online documentation for
the <code>re</code> module.</p>
<p>Scroll down the resulting page until you find
<code>split(Subject, RE, Options) &#8594; SplitList</code> and read the examples.</p>
<p>When you write the <code>-spec</code> for this function (you <em>have</em> been
writing documentation for your functions, haven&#8217;t you?), the type
you will use for the parameter is <code>string()</code>.</p>
<div data-type="note" class="note">
You can see a complete
list of the built-in types at <a href="http://www.erlang.org/doc/reference_manual/typespec.html">http://www.erlang.org/doc/reference_manual/typespec.html</a>
</div>
<p>Yes, I know this étude seems pointless, but trust me:
I&#8217;m going somewhere with this. Stay tuned.</p>
<p><a data-type="xref" href="#SOLUTION05-ET02">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="LISTS">
<h1>Lists</h1>
<div data-type="note" class="note">
You can learn more about working with lists in Chapter 2 of <em>Erlang Programming</em>, Sections 2.10 and 3.5 of <em>Programming Erlang</em>, Section 2.2.5 of <em>Erlang and OTP in Action</em>, and Chapter 1 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH06-ET01">
<h1>Étude 6-1: Recursive Iteration through a List</h1>
<p>In a module named <code>stats</code>, write a function named <code>minimum/1</code>. It takes
a list of numbers as its argument and returns the smallest value. This
function already exists in the <code>lists</code> module (<code>lists:min/1</code>), but it&#8217;s
a good exercise in learning about recursion.</p>
<p>Here&#8217;s the pseudocode for <code>minimum/1</code>.</p>
<ul>
<li><p>Split the list into the first number and the remainder of the list using
the cons operator <code>|</code>.</p></li>
<li><p>Call function <code>minimum/2</code>, which takes a list as its first argument and
the "smallest number so far" (the <em>current candidate</em>) as its second argument.
Use the remainder of the list (which you extracted in the previous step) as
the first argument to <code>minimum/2</code>, and the first item in the list as the second
argument.</p></li>
</ul>
<p>Here&#8217;s the pseudocode for <code>minimum/2</code>.</p>
<ul>
<li><p>When the list passed to <code>minimum/2</code> is empty, the final result is the current
candidate. This stops the recursion.</p></li>
<li><p>If the list passed to <code>minimum/2</code> is not empty, then see if the head of
the list is less than the current candidate.</p>
<ul>
<li><p>If so, call <code>minimum/2</code> with the tail of the list as the first argument
and the list head (the new "smallest number") as the second argument.</p></li>
<li><p>If not, call <code>minimum/2</code> with the tail of the list as the first argument
and the current candidate (still the "smallest number")
as the second argument.</p></li>
</ul>
</li>
</ul>
<p>Unlike most examples in
<a href="http://shop.oreilly.com/product/0636920025818.do">Introducing Erlang</a>,
passing an empty list to this
function will make it crash. That&#8217;s a reasonable thing to do, as an empty
list can&#8217;t really be said to have a minimum value.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(stats).
{ok,stats}
2&gt; N = [4, 1, 7, -17, 8, 2, 5].
[4,1,7,-17,8,2,5]
3&gt; stats:minimum(N).
-17
4&gt; stats:minimum([]).
** exception error: no match of right hand side value []
     in function  stats:minimum/1 (stats.erl, line 15)
5&gt; stats:minimum([52.46]).
52.46</pre>
<p><a data-type="xref" href="#SOLUTION06-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH06-ET02">
<h1>Étude 6-2: Iteration through Lists (More Practice)</h1>
<p>Add two more functions to the <code>stats</code> module:</p>
<p><code>maximum/1</code>, which is just
the same as <code>minimum/1</code>, but don&#8217;t forget&#8212;as I did&#8212;to reverse the direction
of your test for "smaller" to become a test for "larger." (This function
also already exists as <code>lists:max/1</code>.)</p>
<p><code>range/1</code>, which takes a list of numbers as its argument and returns a
list of two numbers: the minimum and maximum entries in the list.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(stats).
{ok,stats}
2&gt; N = [4, 1, 7, -17, 8, 2, 5].
[4,1,7,-17,8,2,5]
3&gt; stats:maximum(N).
8
4&gt; stats:range(N).
[-17,8]</pre>
<p><a data-type="xref" href="#SOLUTION06-ET02">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH06-ET03">
<h1>Étude 6-3: Accumulating the Sum of a List</h1>
<p>Add a function <code>julian/1</code> to the <code>dates</code> module that you wrote in
<a data-type="xref" href="#CH05-ET02">Étude 5-2</a>. Given a string in ISO format (<code>"yyyy-mm-dd"</code>), it
returns the Julian date: the day of the year.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(dates).
{ok,dates}
2&gt; dates:julian("2012-12-31").
366
3&gt; dates:julian("2013-12-31").
365
4&gt; dates:julian("2012-02-05").
36
5&gt; dates:julian("2013-02-05").
36
6&gt; dates:julian("1900-03-01").
60
7&gt; dates:julian("2000-03-01").
61
126&gt; dates:julian("2013-01-01").
1</pre>
<p>The <code>julian/1</code> function defines a 12-item list called <code>DaysPerMonth</code> that
contains the number of days in each month, splits the date into
the year, month, and day (using the <code>date_parts/1</code> function you wrote in
<a data-type="xref" href="#CH05-ET02">Étude 5-2</a>, and then calls helper function <code>julian/5</code> (yes,
five arguments).</p>
<p>The <code>julian/5</code> function does all of the work. Its arguments are the year,
month, day, the list of days per month, and an accumulated total, which
starts at zero. <code>julian/5</code> takes the head of the days per month list and
adds it to the accumulator, and then calls <code>julian/5</code> again with the
tail of the days per month list and the accumulator value as its last two
arguments.</p>
<p>Let&#8217;s take, as an example, the sequence of calls for April 18, 2013:</p>
<pre>julian(2013, 4, 18, [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], 0).
julian(2013, 4, 18, [28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], 31).
julian(2013, 4, 18, [31, 30, 31, 30, 31, 31, 30, 31, 30, 31], 59).
julian(2013, 4, 18, [30, 31, 30, 31, 31, 30, 31, 30, 31], 90).</pre>
<p>At this point, the accumulator has all the days up through the beginning of
April, so the last call to <code>julian/5</code> just adds the 18 remaining days
and yields 108 as its result.</p>
<p>You know you are doing the last call when you have "used up"
the first <em>month-1</em> items in
the list of days per month. That happens <code>when</code> the month number is greater
than <code>(13 - length(<em>days_per_month_list</em>))</code>. Hint: use a guard.</p>
<p>Of course, there&#8217;s still the problem of leap years. You can handle it in
either <code>julian/5</code> or <code>julian/1</code>.</p>
<p>If you want to do the work in <code>julian/5</code>, then for non-leap years,
the last call to <code>julian/5</code> adds the number of days in the target month.
For leap years, the function must add the number of days in the
target month plus one&#8212;but only if the month is after February.</p>
<p>If you want to do the work in <code>julian/5</code>, use a <code>case</code> to assign either
<code>28</code> or <code>29</code> to a variable named <code>DaysInFeb</code> (depending on whether the
year is a leap year), and then use that variable instead of 28 when you
construct your original days per month list.</p>
<p>I&#8217;ll give you the code for the <code>is_leap_year/1</code> function for free; it returns
<code>true</code> if the given year is a leap year, <code>false</code> otherwise.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">is_leap_year(Year) -&gt;
  (Year rem 4 == 0 andalso Year rem 100 /= 0)
  orelse (Year rem 400 == 0).</pre>
<p><a data-type="xref" href="#SOLUTION06-ET03">See suggested solutions in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH06-INTERLUDE">
<h1>Interlude: "Mistakes were made."</h1>
<p>As I was writing the next two études, I tried, despite the examples in the
book, to avoid using <code>lists:reverse/1</code>. I thought, "Why <em>can&#8217;t</em> I add items
to the end of a list using the cons (vertical bar; <code>|</code>) notation?" Here&#8217;s why.</p>
<p>I decided to do a simple task: take a list of numbers and return a list
consisting of the squares of the numbers. I tried adding new items to the end
of the list with this code:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(bad_code).
-export([squares/1]).

squares(Numbers) -&gt; squares(Numbers, []).

squares([], Result) -&gt; Result;

squares([H | T], Result) -&gt; squares(T, [Result | H * H ]).</pre>
<p>The resulting list was in the correct order, but it was an improper list.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(bad_code).
{ok,bad_code}
2&gt; bad_code:squares([9, 4.22, 5]).
[[[[]|81]|17.8084]|25]</pre>
<p>That didn&#8217;t work. Wait a minute&#8212;the book said that the right hand side of the
cons (<code>|</code>) operator should be a list. "OK, you want a list?" I thought.
"I&#8217;ve got your list right here." (See the last
line of the code, where I wrap the new item in square brackets.)</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">squares2(Numbers) -&gt; squares2(Numbers, []).

squares2([], Result) -&gt; Result;

squares2([H | T], Result) -&gt; squares2(T, [Result | [H * H] ]).</pre>
<p>There. That should do the trick.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">6&gt; c(bad_code).
{ok,bad_code}
7&gt; bad_code:squares2([9, 4.22, 5]).
[[[[],81],17.8084],25]</pre>
<p>The result was better, but only slightly better. I didn&#8217;t have an improper list
any more, but now I had a list of list of list of lists.
I could fix the problem by changing one line to flatten the final result.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">squares2([], Result) -&gt; lists:flatten(Result);</pre>
<p>That worked, but it wasn&#8217;t a satisfying solution.</p>
<ul>
<li><p>The longer the original list, the more deeply nested the final list
would be,</p></li>
<li><p>I still had to call a function from the <code>lists</code> module, and</p></li>
<li><p>A look at <a href="http://www.erlang.org/doc/efficiency_guide/listHandling.html">http://www.erlang.org/doc/efficiency_guide/listHandling.html</a> showed
that <code>lists:flatten</code> is a very expensive operation.</p></li>
</ul>
<p>In light of all of this, I decided to use <code>lists:reverse/1</code> and write
the code to generate a proper, non-nested list.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(good_code).
-export([correct_squares/1]).

correct_squares(Numbers) -&gt; correct_squares(Numbers, []).

correct_squares([], Result) -&gt; lists:reverse(Result);

correct_squares([H | T], Result) -&gt;
  correct_squares(T, [H * H | Result]).</pre>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(good_code).
{ok,good_code}
2&gt; good_code:correct_squares([9, 4.22, 5]).
[81,17.8084,25]</pre>
<p>Success at last!  The moral of the story?</p>
<ul>
<li><p>RTFM (Read the Fabulous Manual).</p></li>
<li><p>Believe what you read.</p></li>
<li><p>If you don&#8217;t believe what you read, try it and find out.</p></li>
<li><p>Don&#8217;t worry if you make this sort of mistake. You won&#8217;t be the first person
to do so, and you certainly won&#8217;t be the last.</p></li>
<li><p>When using cons, "lists come last."</p></li>
</ul>
<p>OK. Back to work.</p>
</section>






<section class="sect1" data-type="sect1" id="CH06-ET04">
<h1>Étude 6-4: Lists of Lists</h1>
<p>Dentists check the health of your gums by checking the depth of the "pockets"
at six different locations around each of your 32 teeth.
The depth is measured in millimeters. If any of the depths is greater
than or equal to four millimeters, that tooth needs attention. (Thanks to
Dr. Patricia Lee, DDS, for explaining this to me.)</p>
<p>Your task is to write a module named <code>teeth</code> and a function named
<code>alert/1</code>. The function takes a list of 32 lists of six numbers as its
input. If a tooth isn&#8217;t present, it is represented by the list
<code>[0]</code> instead of a list of six numbers. The function produces
a list of the tooth numbers that require attention.  The numbers
must be in ascending order.</p>
<p>Here&#8217;s a set of pocket depths for a person who has had her
upper wisdom teeth, numbers 1 and 16, removed. Just copy and paste it.</p>
<pre>PocketDepths = [[0], [2,2,1,2,2,1], [3,1,2,3,2,3],
[3,1,3,2,1,2], [3,2,3,2,2,1], [2,3,1,2,1,1],
[3,1,3,2,3,2], [3,3,2,1,3,1], [4,3,3,2,3,3],
[3,1,1,3,2,2], [4,3,4,3,2,3], [2,3,1,3,2,2],
[1,2,1,1,3,2], [1,2,2,3,2,3], [1,3,2,1,3,3], [0],
[3,2,3,1,1,2], [2,2,1,1,3,2], [2,1,1,1,1,2],
[3,3,2,1,1,3], [3,1,3,2,3,2], [3,3,1,2,3,3],
[1,2,2,3,3,3], [2,2,3,2,3,3], [2,2,2,4,3,4],
[3,4,3,3,3,4], [1,1,2,3,1,2], [2,2,3,2,1,3],
[3,4,2,4,4,3], [3,3,2,1,2,3], [2,2,2,2,3,3],
[3,2,3,2,3,2]].</pre>
<p>And here&#8217;s the output:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(teeth).
{ok,teeth}
2&gt; teeth:alert(PocketDepths).
[9,11,25,26,29]</pre>
<p><a data-type="xref" href="#SOLUTION06-ET04">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH06-ET05">
<h1>Étude 6-5: Random Numbers; Generating Lists of Lists</h1>
<p>How do you think I got the numbers for the teeth in the preceding étude?
Do you really think I made up and typed all 180 of them? No, of course not.
Instead, I wrote an Erlang program to create the list of lists for me,
and that&#8217;s what you&#8217;ll do in this étude.</p>
<p>In order to create the data for the teeth,
I had to generate random numbers with Erlang&#8217;s
<code>random</code> module. Try generating a random number uniformly
distributed between 0 and 1.0 by typing this in <code>erl</code>:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; random:uniform().
0.4435846174457203</pre>
<p>Now, exit <code>erl</code>, restart, and type the same command again. You&#8217;ll get the
same number. In order to ensure that you get different sets of random numbers,
you have to <em>seed</em> the random number generator with a three-tuple. The easiest
way to get a different seed every time you run the program is to use the
<code>now/0</code> built-in function, which returns a different three-tuple every time
you call it.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; now().
{1356,887000,432535}
2&gt; now().
{1356,887002,15527}
3&gt; now().
{1356,887003,831752}</pre>
<p>Exit <code>erl</code>, restart, it and try these commands. Do this a couple of times to
convince yourself that you really get different random numbers. Don&#8217;t worry
about the <code>undefined</code>; that&#8217;s just Erlang&#8217;s way of telling you that the
random number generator wasn&#8217;t seeded before.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; random:seed(now()).
undefined
2&gt; random:uniform().
0.27846009966109264</pre>
<p>If you want to generate a random integer between 1 and <code>N</code>, use
<code>uniform/1</code>; thus <code>random:uniform(10)</code> will generate a
random integer from 1 to 10.</p>
<p>Functions that use random numbers have side effects; unlike the <code>sin</code> or
<code>sqrt</code> function, which always gives you the same numbers for the same input,
functions that use random numbers should always give you different numbers
for the same input. Since these functions aren&#8217;t "pure," it&#8217;s best to isolate
them in a module of their own.</p>
<p>In this étude, create a module named <code>non_fp</code>, and write a function
<code>generate_teeth/2</code>. This function has a string consisting of the characters
<code>T</code> and <code>F</code> for its first argument.
A <code>T</code> in the string indicates that the tooth is present, and a
<code>F</code> indicates a missing tooth. In Erlang, a string is a list of characters,
so you can treat this string just as you would any other list. Remember to
refer to individual characters as <code>$T</code> and <code>$F</code>.</p>
<p>The second argument is a floating point
number between 0 and 1.0 that indicates the probability that a tooth will be
a good tooth.</p>
<p>These are the helper functions I needed:</p>

<dl>
<dt><code>generate_teeth/3</code></dt>
<dd><p>The first two arguments are the same as for <code>generate_teeth/2</code>; the
third argument is the accumulated list. When the first argument is
an empty list, the function yields the reverse of the accumulated list.</p></dd>
<dt><code>generate_tooth/1</code></dt>
<dd><p>This generates the list of numbers for a single tooth. It generates a
random number between 0 and 1. If that number is less than the probability
of a good tooth, it sets the "base depth" to 2, otherwise it sets the base depth to 3.</p></dd>
<dt><code>generate_tooth/3</code></dt>
<dd><p>The first argument is the base depth, the second is the number of items
left to generate, and the third argument is the accumulated list. When
the number of items hits zero, the function is finished. Otherwise, it
adds a random integer between -1 and 1 to the base depth,
adds it to the accumulated list, and does a recursive call with
one less item.</p></dd>
</dl>
<p><a data-type="xref" href="#SOLUTION06-ET05">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="HIGHER-ORDER_FNS">
<h1>Higher Order Functions and List Comprehensions</h1>
<div data-type="note" class="note">
You can learn more about working with higher order functions in Chapter 9 of <em>Erlang Programming</em>, Section 3.4 of <em>Programming Erlang</em>, Section 2.7 of <em>Erlang and OTP in Action</em>, and Chapter 6 of <em>Learn You Some Erlang For Great Good!</em>.  List comprehensions are in Chapter 9 of <em>Erlang Programming</em>, Section 3.6 of <em>Programming Erlang</em>, Section 2.9 of <em>Erlang and OTP in Action</em>, and Chapter 1 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH07-ET01">
<h1>Étude 7-1: Simple Higher Order Functions</h1>
<p>In calculus, the derivative of a function is "a measure of how a function
changes as its input changes"
(<a href="http://en.wikipedia.org/wiki/Derivative">Wikipedia</a>). For example,
if an object is traveling at a constant velocity, that velocity is the same
from moment to moment, so the derviative is zero. If an object is falling, its
velocity changes a little bit as the object starts falling, and then falls
faster and faster as time goes by.</p>
<p>You can calculate the rate of change of a function by calculating:
<code>(F(X + Delta) - F(X)) / Delta</code>, where <code>Delta</code> is the interval
between measurements. As Delta approaches zero, you get closer and
closer to the true value of the derivative.</p>
<p>Write a module named <code>calculus</code> with a function <code>derivative/2</code>. The
first argument is the function whose derivative you wish to find, and the
second argument is the point at which you are measuring the derivative.</p>
<p>What should you use for a value of <code>Delta</code>? I used <code>1.0e-10</code>, as that is a small
number that approaches zero.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(calculus).
{ok,calculus}
2&gt; F1 = fun(X) -&gt; X * X end.
#Fun&lt;erl_eval.6.82930912&gt;
3&gt; F1(3).
9
4&gt; calculus:derivative(F1, 3).
6.000000496442226
5&gt; calculus:derivative(fun(X) -&gt; 3 * X * X + 2 * X + 1 end, 5).
32.00000264769187
6&gt; calculus:derivative(fun math:sin/1, 0).
1.0</pre>
<ul>
<li><p>Line 3 is a test to see if the <code>F1</code> function works.</p></li>
<li><p>Line 5 shows that you don&#8217;t have to assign a function to a variable;
you can define the function in line.</p></li>
<li><p>Line 6 shows how to refer to a function in another module. You start
with the word <code>fun</code> followed by the <code><em>module</em>:<em>function</em>/<em>arity</em></code>.</p></li>
</ul>
<p><a data-type="xref" href="#SOLUTION07-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH07-ET02">
<h1>Étude 7-2: List Comprehensions and Pattern Matching</h1>
<p>Is it possible to use pattern matching inside a list comprehension? Try
it and find out.</p>
<p>Presume you have this list of people&#8217;s names, genders, and ages:</p>
<pre>People = [{"Federico", $M, 22}, {"Kim", $F, 45}, {"Hansa", $F, 30},
{"Tran", $M, 47}, {"Cathy", $F, 32}, {"Elias", $M, 50}].</pre>




<section class="sect2" data-type="sect2" id="_part_one">
<h2>Part One</h2>
<p>In <code>erl</code> (or in a module, if you prefer), write a list comprehension
that creates a list consisting of the names of all males who are over 40.
Use pattern matching
to separate the tuple into three variables, and two guards to do the
tests for age and gender.</p>
</section>






<section class="sect2" data-type="sect2" id="_part_two">
<h2>Part Two</h2>
<p>When you use multiple guards in a list comprehension, you get the moral
equivalent of <code>and</code> for each condition you are testing. If you want an
<code>or</code> condition, you must test it explicitly. Write a list comprehension
that selects the names of all the people who are male <em>or</em> over 40. You
will need one guard with an <code>or</code>; you may also use <code>orelse</code>.</p>
<div data-type="note" class="note">
Because <code>or</code> has higher priority than comparison operators like <code>&lt;</code> and
<code>==</code>, an expression like <code>X &gt; 5 or X &lt; 12</code> will generate an error, as
Erlang interprets it to mean <code>X &gt; (5 or X) &lt; 12</code>. Use parentheses to force
the correct evaluation: <code>(X &gt; 5) or (X &lt; 12)</code>. If you use <code>orelse</code>, which
has a lower priority than the comparison operators, you don&#8217;t need the
parentheses, though it doesn&#8217;t hurt to have them. Another advantage of
<code>orelse</code> is that it doesn&#8217;t do any unnecessary comparisons.
</div>
</section>


</section>






<section class="sect1" data-type="sect1" id="CH07-ET03">
<h1>Étude 7-3: Using <code>lists:foldl/3</code></h1>
<p>Add <code>mean/1</code> and <code>stdv/1</code> functions to the <code>stats</code> module which
you created in <a data-type="xref" href="#CH06-02">Étude 6-2</a> to calculate the mean and
standard deviation for a list of numbers.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(stats).
{ok,stats}
2&gt; stats:mean([7, 2, 9]).
6.0
3&gt; stats:stdv([7, 2, 9]).
3.605551275463989</pre>
<p>The formula for the mean is simple; just add up all the numbers and
divide by the number of items in the list (which you may find by using the
<code>length/1</code> function).Use <code>lists:foldl/3</code> to calculate the sum of the items
in the list.</p>
<p>The following is the algorithm for calculating
the standard deviation. Presume that <code>N</code> is the number of items
in the list.</p>
<ol>
<li><p>Add up all the numbers in the list (call this the <em>sum</em>).</p></li>
<li><p>Add the squares of the numbers in the list (call this the <em>sum of squares</em>).</p></li>
<li><p>Multiply <code>N</code> times the <em>sum of squares</em>.</p></li>
<li><p>Multiply the <em>sum</em> times itself.</p></li>
<li><p>Subtract the result of step 4 from the result of step 3.</p></li>
<li><p>Divide the result of step 5 by <code>N * (N - 1)</code>.</p></li>
<li><p>Take the square root of that result.</p></li>
</ol>
<p>Thus, if your numbers are 7, 2, and 9, <code>N</code> would be three, and
you would do these calculations:</p>
<ul>
<li><p>The sum is 7 + 2 + 9, or 18.</p></li>
<li><p>The sum of squares is 49 + 4 + 81, or 134.</p></li>
<li><p><code>N</code> times the sum of squares is 134 * 3, or 402.</p></li>
<li><p>The sum times itself is 18 * 18, or 324.</p></li>
<li><p>402 - 324 is 78.</p></li>
<li><p>78 divided by (3 * (3 - 1)) is 78 / 6, or 13.</p></li>
<li><p>The standard deviation is the square root of 13, or 3.606.</p></li>
</ul>
<p>In your code, you can do steps three through seven in one arithmetic
expression. You&#8217;d have variables in your expression rather than constants,
of course.</p>
<pre>math:sqrt((3 * 134 - 18 * 18)/(3 * (3 - 1))</pre>
<p>Use <code>lists:foldl/3</code> to calculate the sum and the sum of squares.
Bonus points if you can calculate both of them
with one call to <code>lists:foldl/3</code>. Hint:
the argument for the accumulator doesn&#8217;t have to be a single number. It can
be a list or a tuple.</p>
<p><a data-type="xref" href="#SOLUTION07-ET03">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH07-ET04">
<h1>Étude 7-4: Using <code>lists:split/2</code></h1>
<p>Use <code>erl -man lists</code> to see how the <code>lists:split/2</code> function works, or try
the following example and see if you can figure it out. Experiment to see
what happens if the first argument is zero.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; lists:split(4, [110, 220, 330, 440, 550, 660]).
{[110,220,330,440],[550,660]}</pre>
<p>Use <code>lists:split/2</code> and <code>lists:foldl/3</code> to rewrite the
<code>dates:julian/1</code> function from
<a data-type="xref" href="#CH06-03">Étude 6-3</a>. Hint: you&#8217;ll use those functions when
calculating the total number of days up to (but not including)
the month in question.</p>
<p><a data-type="xref" href="#SOLUTION07-ET04">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH07-ET05">
<h1>Étude 7-5: Multiple Generators in List Comprehensions</h1>
<p>Back to list comprehensions. You can have more than one generator in a list
comprehension. Try this in <code>erl</code>:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; [X * Y || X &lt;- [3, 5, 7], Y &lt;- [2, 4, 6]].
[6,12,18,10,20,30,14,28,42]</pre>
<p>Using what you&#8217;ve learned from this example, write a module named <code>cards</code>
that contains a function <code>make_deck/0</code>. The function will generate a deck
of cards as a list 52 tuples in this form:</p>
<pre>[{"A","Clubs"},
 {"A","Diamonds"},
 {"A","Hearts"},
 {"A","Spades"},
 {2,"Clubs"},
 {2,"Diamonds"},
 {2,"Hearts"},
 {2,"Spades"},
 ...
 {"K", "Clubs"},
 {"K", "Diamonds"},
 {"K", "Hearts"},
 {"K", "Spades"}]</pre>
<div data-type="note" class="note">
<p>When you run this function, your output will not show the entire list; it will
show something that ends like this. Don&#8217;t freak out.</p>
<pre></pre>
<p>{7,"Clubs"},
{7,"Diamonds"},
{7,[&#8230;]},
{7,&#8230;},
{&#8230;}|&#8230;]</p>
<p>If you want to see the full list, use this function.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">show_deck(Deck) -&gt;
  lists:foreach(fun(Item) -&gt; io:format("~p~n", [Item]) end, Deck).</pre>
</div>
<p><a data-type="xref" href="#SOLUTION07-ET05">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH07-ET06">
<h1>Étude 7-6: Explaining an Algorithm</h1>
<p>You need a way to shuffle the deck of cards. This is the code for
doing a shuffle, taken from the Literate Programs Wiki.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">shuffle(List) -&gt; shuffle(List, []).
shuffle([], Acc) -&gt; Acc;
shuffle(List, Acc) -&gt;
  {Leading, [H | T]} = lists:split(random:uniform(length(List)) - 1, List),
  shuffle(Leading ++ T, [H | Acc]).</pre>
<p>Wait a moment. If I&#8217;ve just given you the code, what&#8217;s the purpose
of this étude? I want you to understand the code. The object of this
étude is to write the documentation for the algorithm.
If you aren&#8217;t sure what the code does, try adding some
<code>io:format</code> statements to see what is happening. If you&#8217;re totally
stuck, <a href="http://en.literateprograms.org/Fisher-YatesShuffle_%28Erlang%29">see the explanation from Literate Programs site</a>.</p>
<p><a data-type="xref" href="#SOLUTION07-ET06">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="PROCESSES">
<h1>Processes</h1>
<div data-type="note" class="note">
You can learn more about working with simple processes in Chapter 4 of <em>Erlang Programming</em>, Chapter 8 of <em>Programming Erlang</em>, Section 2.13 of <em>Erlang and OTP in Action</em>, and Chapters 10 and 11 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH08-ET01">
<h1>Étude 8-1: Using Processes to Simulate a Card Game</h1>
<p>There is only one étude for this chapter. You&#8217;re going to
write an Erlang program that lets the computer play the card
game of "War" against itself.</p>




<section class="sect2" data-type="sect2" id="_the_art_of_war">
<h2>The Art of War</h2>
<p>These are the rules of the game as condensed from
<a href="http://en.wikipedia.org/wiki/War_%28card_game%29,Wikipedia">Wikipedia</a>, adapted
to two players, and simplified further.</p>
<p>Two players each take 26 cards from a shuffled deck. Each person
puts her top card face up on the table. Whoever has the higher
value card wins that battle, takes both cards, and puts
them at the bottom of her stack. What happens the if the cards
have the same value?
Then the players go to "war." Each person puts the next two cards from
their stack face down in the pile and a third card face up. High card
wins, and the winner takes all the cards for the bottom of her stack.
If the cards match again, the war continues with another set of three cards from
each person. If a person has fewer than three cards
when a war happens, he puts in all his cards.</p>
<p>Repeat this entire procedure until one person has all the cards. That player
wins the game. In this game, aces are considered to have the highest value,
and King &gt; Queen &gt; Jack.</p>
</section>






<section class="sect2" data-type="sect2" id="_war_what_is_it_good_for">
<h2>War: What is it good for?</h2>
<p>Absolutely nothing. Well, almost nothing. War is possibly the most
incredibly inane card game ever invented. It is a great way for children
to spend time, and it&#8217;s perfect as an étude because</p>
<ul>
<li><p>it is naturally implementable as processes (players) passing messages
(cards)</p></li>
<li><p>there is no strategy involved in the play, thus allowing you to concentrate
on the processes and messages</p></li>
</ul>
</section>






<section class="sect2" data-type="sect2" id="_pay_now_or_pay_later">
<h2>Pay Now or Pay Later</h2>
<p>When you purchase an item, if you pay cash on the spot, you often end up paying
less than if you used credit. If you are cooking a meal, getting all of the
ingredients collected before you start (pay now) is often less stressful than
having to stop and go to the grocery store for items you found out you didn&#8217;t
have (pay later). In most cases, "pay now" ends up being less expensive than
"pay later," and that certainly applies to most programming tasks.</p>
<p>So, before you rush off to start writing code, let me give you a word of advice:
Don&#8217;t. Spend some time with paper and pencil, away from the computer, and
<em>design</em> this program first. This is a non-trivial program, and the "extra"
time you spend planning it (pay now) will save you a lot of time in
debugging and rewriting (pay later). As someone once told me, "Hours of
programming will save you minutes of planning."</p>
<p>Trust me, programs written at the keyboard look like it, and that
is not meant as a compliment.</p>
<p>Note: This does not mean that you should never use <code>erl</code> or write anything
at the keyboard. If you are wondering about how a specific part of Erlang
works and need to write a small test program to find out, go ahead and do that
right away.</p>
<p>Hint: Do your design on paper. Don&#8217;t try to keep the whole thing in your
head. Draw diagrams. Sometimes a picture or a storyboard of how the
messages should flow will clarify your thinking. (If your parents ever
asked you, "Do I have to draw you a diagram?", you may now confidently
answer "Yes. Please do that. It really helps.")</p>
</section>






<section class="sect2" data-type="sect2" id="_the_design">
<h2>The Design</h2>
<p>When I first started planning this, I was going to have just two processes
communicating with one another, as it is in a real game. But let&#8217;s think
about that. There is a slight asymmetry between the players. One
person usually brings the cards and suggests playing the game. He shuffles
the deck and deals out the cards at the beginning. Once that&#8217;s done,
things even out. The game play itself proceeds almost automatically. Neither
player is in control of the play, yet both of them are. It seems as if
there is an implicit, almost telepathic communication between the players.
Actually, there are no profound metaphysical issues here. Both players
are simultaneously following the same set of rules. And that&#8217;s the point that
bothered me&#8212;who makes the "decisions" in the program? I decided to sidestep
the issue by introducing a third agent, the "dealer," who is responsible for
giving the cards to each player at the start of the game. The dealer then
can tell each player to turn over cards, make a decision as to who won, and
then tell a particular player to take cards. This simplifies the message
flow considerably and also fits in nicely with the OTP concepts of supervisors
and servers, covered in Chapter 10 of
<a href="http://shop.oreilly.com/product/0636920025818.do">Introducing Erlang</a>.</p>
<p>In my code, the dealer had to keep track of:</p>
<ul>
<li><p>The process IDs of the players (this was a list)</p></li>
<li><p>The current state of play (see the following)</p></li>
<li><p>Cards received from player 1 for this battle</p></li>
<li><p>Cards received from player 2 for this battle</p></li>
<li><p>The number of players who had given the dealer cards so far (0, 1, or 2)</p></li>
<li><p>The pile of cards in the middle of the table</p></li>
</ul>
<p>The dealer spawns the players, and then is in one of the following states.
I&#8217;m going to anthropomorphize and use "me" to represent the dealer.</p>

<dl>
<dt>Pre-battle</dt>
<dd><p>Tell the players to send me cards. If the pile is empty, then
it&#8217;s a normal battle; give me one card each. If the pile isn&#8217;t empty, then
it&#8217;s a war; give me three cards.</p></dd>
<dt>Await battle</dt>
<dd><p>Wait to receive the cards from the players. Add one to the count every
time I get a player&#8217;s cards. When the count reaches two, I&#8217;m ready for&#8230;</p></dd>
<dt>Check Cards</dt>
<dd><p>If either player has sent me an empty list for their cards, then that player
is out of cards, so the other player must be the winner.</p></dd>
</dl>
<p>Note that this is my implementation; you may find an entirely
different and better way to write the program.</p>
</section>






<section class="sect2" data-type="sect2" id="_messages_are_asynchronous">
<h2>Messages Are Asynchronous</h2>
<p>Remember that the order in which a process receives messages may
not be the same order in which they were sent. For example, if players
Andrea and Bertram have a battle, and Andrea wins,
you may be tempted to send these messages:</p>
<ol>
<li><p>Tell Andrea to pick up the two cards that were in the battle.</p></li>
<li><p>Tell Andrea to send you a card for the next battle.</p></li>
<li><p>Tell Bertram to send you a card for the next battle.</p></li>
</ol>
<p>This works nicely unless Andrea had just thrown her last card down
for that battle and message two arrives <em>before</em> message one.
Andrea will report that she is out of cards, thus losing the game,
even though she&#8217;s really still in the game with the two cards that
she hasn&#8217;t picked up yet.</p>
</section>






<section class="sect2" data-type="sect2" id="_hints_for_testing">
<h2>Hints for Testing</h2>
<p>Modify the <code>cards</code> module that you wrote in <a data-type="xref" href="#CH07-ET06">Étude 7-6</a>
to generate a small deck with, say, only
four cards in two suits. If you try to play with a full deck, the game could
go on for a very, very long time.</p>
<p>Use plenty of calls to <code>io:format/2</code> to see what your code is really doing.</p>
<p><a data-type="xref" href="#SOLUTION08-ET01">See a suggested solution in Appendix A.</a></p>
</section>


</section>



</section>






<section data-type="chapter" id="HANDLING_ERRORS">
<h1>Handling Errors</h1>
<div data-type="note" class="note">
You can learn more about error handling in Chapters 3 and 17 of <em>Erlang Programming</em>, Chapter 4 and Section 18.2 of <em>Programming Erlang</em>, Section 2.8 and Chapters 5 and 7 of <em>Erlang and OTP in Action</em>, and Chapters 7 and 12 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH09-ET01">
<h1>Étude 9-1: <code>try</code> and <code>catch</code></h1>
<p>Update the <code>stats</code> module that you wrote in <a data-type="xref" href="#CH07-ET03">Étude 7-3</a>
so that it will catch errors in the <code>minimum/1</code>, <code>maximum/1</code>,
<code>mean/1</code> and <code>stdv/1</code> functions.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(stats).
{ok,stats}
2&gt; stats:minimum([]).
{error,badarg}
3&gt; stats:mean([]).
{error,badarith}
4&gt; stats:mean(["123", 456]).
{error,badarith}
5&gt; stats:stdv([]).
{error,badarith}</pre>
<p><a data-type="xref" href="#SOLUTION09-ET01">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH09-ET02">
<h1>Étude 9-2: Logging Errors</h1>
<p>Write a module named <code>bank</code> that contains a function <code>account/1</code>. The
function takes a numeric <code>Balance</code>, which gives the current balance in
the account in imaginary dollars.</p>
<p>The function will repeatedly ask for a transaction (deposit, withdraw,
balance inquiry, or quit). If a deposit or withdrawal, it asks for the amount
to deposit or withdraw, and then does that transaction. If a deposit is
more than $10,000, the deposit may be subject to hold.</p>
<p>Provide output to the customer, and also use <code>error_logger</code> to write to a
log file (which, in this case, will go to your terminal).
Choose any form of input prompts and feedback and logging messages that you
desire. Handle the following situtations:</p>
<ul>
<li><p>Deposits and withdrawals cannot be negative numbers (error)</p></li>
<li><p>Deposits of $10,000 or more might be subject to hold (warning)</p></li>
<li><p>All other transactions are successful (informational)</p></li>
</ul>
<p>Use <code>get_number/1</code> from <a data-type="xref" href="#CH05-ET01">Étude 5-1</a> to allow either integer
or float input.</p>
<p>Here is sample output. Due to Erlang&#8217;s asynchronous nature,
the user prompts and logging are often interleaved in the most inconvenient
places.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(bank).
{ok,bank}
2&gt; bank:account(2000).
D)eposit, W)ithdraw, B)alance, Q)uit: D
Amount to deposit: 300
Your new balance is 2300
D)eposit, W)ithdraw, B)alance, Q)uit:
=INFO REPORT==== 26-Jan-2013::06:42:52 ===
Successful deposit 300
W
Amount to withdraw: -200
Withdrawals may not be less than zero.
=ERROR REPORT==== 26-Jan-2013::06:42:56 ===
Negative withdrawal amount -200
D)eposit, W)ithdraw, B)alance, Q)uit: D
Amount to deposit: 15000
Your deposit of $15000 may be subject to hold.
=ERROR REPORT==== 26-Jan-2013::06:43:05 ===
Excessive deposit 15000
Your new balance is 17300
D)eposit, W)ithdraw, B)alance, Q)uit: W
Amount to withdraw: 32767
You cannot withdraw more than your current balance of 17300.

=ERROR REPORT==== 26-Jan-2013::06:43:17 ===
Overdraw 32767 from balance 17300
D)eposit, W)ithdraw, B)alance, Q)uit: W
Amount to withdraw: 150.25
Your new balance is 17149.75

=INFO REPORT==== 26-Jan-2013::06:43:29 ===
Successful withdrawal 150.25
D)eposit, W)ithdraw, B)alance, Q)uit: B
D)eposit, W)ithdraw, B)alance, Q)uit:
=INFO REPORT==== 26-Jan-2013::06:43:35 ===
Balance inquiry 17149.75
X
Unknown command X
D)eposit, W)ithdraw, B)alance, Q)uit: Q
true</pre>
<p><a data-type="xref" href="#SOLUTION09-ET02">See a suggested solution in Appendix A.</a></p>
</section>



</section>






<section data-type="chapter" id="STORING-STRUCTURED-DATA">
<h1>Storing Structured Data</h1>
<div data-type="note" class="note">
You can learn more about working with records in Chapter 7 of <em>Erlang Programming</em>, Section 3.9 of <em>Programming Erlang</em>, Section 2.11 of <em>Erlang and OTP in Action</em>, and Chapter 9 of <em>Learn You Some Erlang For Great Good!</em>.  ETS and DETS are in Chapter 10 of <em>Erlang Programming</em>, Chapter 15 of <em>Programming Erlang</em>, Section 2.14 and Chapter 6 of <em>Erlang and OTP in Action</em>, and Chapter 25 of <em>Learn You Some Erlang For Great Good!</em>.  Mnesia is covered in Chapter 13 of <em>Erlang Programming</em>, Chapter 17 of <em>Programming Erlang</em>, Section 2.7 of <em>Erlang and OTP in Action</em>, and Chapter 29 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH10-ET01">
<h1>Étude 10-1: Using ETS</h1>
<p>In honor of Erlang&#8217;s heritage as a language designed for
telephony applications, this étude will set up a small
database that keeps track of phone calls.</p>




<section class="sect2" data-type="sect2" id="_part_one_2">
<h2>Part One</h2>
<p>Create a file named <code>phone_records.hrl</code> that defines a record
with these fields:</p>
<ul>
<li><p>Phone number</p></li>
<li><p>Starting date (month, day, and year)</p></li>
<li><p>Starting time (hours, minutes, and seconds)</p></li>
<li><p>End date (month, day, and year)</p></li>
<li><p>End time (hours, minutes, and seconds)</p></li>
</ul>
<p>You may name the record whatever you wish, and you may use any
field names you wish.</p>
</section>






<section class="sect2" data-type="sect2" id="_part_two_2">
<h2>Part Two</h2>
<p>In a module named <code>phone_ets</code>,
create an ETS table for phone calls by reading a file. The function
that does this will be named <code>setup/1</code>, and its argument will be the
name of the file containing the data.</p>
<p>Copy the following text into a file named
<code>call_data.csv</code> and save the file in the same directory where you
did part one.</p>
<pre data-type="programlisting" class="programlisting">650-555-3326,2013-03-10,09:01:47,2013-03-10,09:05:11
415-555-7871,2013-03-10,09:02:20,2013-03-10,09:05:09
729-555-8855,2013-03-10,09:00:55,2013-03-10,09:02:18
729-555-8855,2013-03-10,09:02:57,2013-03-10,09:03:56
213-555-0172,2013-03-10,09:00:59,2013-03-10,09:03:49
946-555-9760,2013-03-10,09:01:20,2013-03-10,09:03:10
301-555-0433,2013-03-10,09:01:44,2013-03-10,09:04:06
301-555-0433,2013-03-10,09:05:17,2013-03-10,09:07:53
301-555-0433,2013-03-10,09:10:05,2013-03-10,09:13:14
729-555-8855,2013-03-10,09:04:40,2013-03-10,09:07:29
213-555-0172,2013-03-10,09:04:26,2013-03-10,09:06:00
213-555-0172,2013-03-10,09:06:59,2013-03-10,09:10:35
946-555-9760,2013-03-10,09:03:36,2013-03-10,09:04:23
838-555-1099,2013-03-10,09:00:43,2013-03-10,09:02:44
650-555-3326,2013-03-10,09:05:48,2013-03-10,09:09:08
838-555-1099,2013-03-10,09:03:43,2013-03-10,09:06:26
838-555-1099,2013-03-10,09:07:54,2013-03-10,09:10:10
301-555-0433,2013-03-10,09:14:07,2013-03-10,09:15:08
415-555-7871,2013-03-10,09:06:15,2013-03-10,09:09:32
650-555-3326,2013-03-10,09:10:12,2013-03-10,09:13:09</pre>
<p>So, how do you read a file? Take just the first three lines,
and put them into a file called <code>smallfile.csv</code>, then do the following
commands from <code>erl</code></p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; {ResultCode, InputFile} = file:open("smallfile.csv", [read]).
{ok,&lt;0.33.0&gt;}
2&gt; io:get_line(InputFile, "").
"650-555-3326,2013-03-10,09:01:47,2013-03-10,09:05:11\n"
3&gt; io:get_line(InputFile, "").
"415-555-7871,2013-03-10,09:02:20,2013-03-10,09:05:09\n"
4&gt; io:get_line(InputFile, "").
"729-555-8855,2013-03-10,09:00:55,2013-03-10,09:02:18\n"
5&gt; io:get_line(InputFile, "").
eof
6&gt; file:open("nosuchfile", [read]).
{error,enoent}</pre>
<p>In the preceding example, lines 1 through 5 show how to open a file
and read it. You can tell you are at the end of file when you get an
atom (<code>eof</code>) instead of a list (remember, Erlang strings are lists).
Line 6 shows what happens if you try to open a file
that doesn&#8217;t exist.</p>
<p>The phone number is the key for this data. Since there are multiple
calls per phone number, you will need a <code>bag</code> type table.
To get the individual items from each line, use
<code>re:split/2</code>, much as you did in <a data-type="xref" href="#CH05-ET02">Étude 5-2</a>.</p>
</section>






<section class="sect2" data-type="sect2" id="_part_three">
<h2>Part Three</h2>
<p>Write functions to summarize the number of minutes for a single
phone number (<code>summary/1</code>) or for all phone numbers.
(<code>summary/0</code>). These functions return a list of tuples in the form:</p>
<p><code>[{<em>phoneNumber1</em>, <em>minutes</em>]},{<em>phoneNumber2</em>, <em>minutes</em>}, &#8230;]</code></p>
<p>You could write your own code to do time and date calculations to
figure out the duration of a phone call, but there&#8217;s a limit on how
much you really want to re-invent the wheel, especially with something
as complex as calendar calculations. Consider, for example, a call that
begins on 31 December 2013 at 11:58:36 p.m. and ends on 1 January 2014 at
12:14:22 p.m. I don&#8217;t even want to think about calls that start on
28 February and go to the next day.</p>
<p>So, instead, use the <code>calendar:datetime_to_gregorian_seconds/1</code> function
to convert a date and time to the number of seconds since the year zero.
(I swear I am not making this up.) The argument to this function is a
tuple in the form:</p>
<pre data-type="programlisting" class="programlisting">{{<em>year</em>, <em>month</em>, <em>day</em>}, {<em>hours</em>, <em>minutes</em>, <em>seconds</em>}} %% for example
{{2013, 07, 14}, {14, 49, 21}}</pre>
<p>Round up any number of seconds to the next minute for ech call. Thus, if
a call lasts 4 minutes and 6 seconds, round it up to 5 minutes.
Hint: add 59 to the total number of seconds before you <code>div 60</code>.</p>
<div data-type="note" class="note">
Now might be the time to rewrite part two so that your dates and times
are stored in the appropriate format. That way, you do the conversion
from string to tuple only once, instead of every time you ask
for a summary.
</div>
<p>Here is the sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(phone_ets).
{ok,phone_ets}
2&gt; phone_ets:setup("call_data.csv").
ok
3&gt; phone_ets:summary("415-555-7871").
[{"415-555-7871",7}]
4&gt; phone_ets:summary().
[{"946-555-9760",3},
 {"415-555-7871",7},
 {"729-555-8855",6},
 {"301-555-0433",12},
 {"213-555-0172",9},
 {"650-555-3326",11}]</pre>
<p><a data-type="xref" href="#SOLUTION10-ET01">See a suggested solution in Appendix A.</a></p>
</section>


</section>






<section class="sect1" data-type="sect1" id="CH10-ET02">
<h1>Étude 10-2: Using Mnesia</h1>
<p>I have good news and bad news. First, the bad news. Mnesia is <em>not</em>
a relational detabase management system. If you try to use a query
list comprehension to join three tables, Erlang will complain that joins
with more than two tables are not efficient.</p>
<p>Now, the good news. While trying to find a way around this, I discovered
something about query list comprehensions that is really pretty neat, and I&#8217;m
happy to share it with you.</p>
<p>In this étude, you will use add a table of customer names and
use Mnesia query list comprehensions to join data
from those tables when producing a summary.</p>




<section class="sect2" data-type="sect2" id="_part_one_3">
<h2>Part One</h2>
<p>You will need to add a record for customers to <code>phone_records.hrl</code>. Its fields
will be:</p>
<ul>
<li><p>Phone Number (this is the key)</p></li>
<li><p>Customer&#8217;s last name</p></li>
<li><p>Customer&#8217;s first name</p></li>
<li><p>Customer&#8217;s middle name</p></li>
<li><p>Rate paid per minute (float)</p></li>
</ul>
<p>Again, you may name the record whatever you wish, and you may use any
field names you wish.</p>
</section>






<section class="sect2" data-type="sect2" id="_part_two_3">
<h2>Part Two</h2>
<p>In a module named <code>phone_mnesia</code>,
create the Mnesia tables for the two files. The function
that does this will be named <code>setup/2</code>, and its arguments will be the
names of the file containing the data.</p>
<p>Use the phone call data from <a data-type="xref" href="#ET10-01">Étude 10-1</a>, and
use this data for the customers. Put it in a file named
<code>customer_data.csv</code> or whatever other name you wish.</p>
<pre data-type="programlisting" class="programlisting">213-555-0172,Nakamura,Noriko,,0.12
301-555-0433,Ekberg,Erik,Engvald,0.07
415-555-7871,Alvarez,Alberto,Agulto,0.15
650-555-3326,Girard,Georges,Gaston,0.10
729-555-8855,Tran,Truong,Thai,0.09
838-555-1099,Smith,Samuel,Steven,0.10
946-555-9760,Bobrov,Bogdan,Borisovitch,0.14</pre>
<p>You could write two functions that all open a file, read data,
split it into fields, write the data to the Mnesia table, and then keep
going until end-of-file. These would share a lot of common code. Instead,
try writing just one function that does the reading, and pass a higher-order
function to it to do the appropriate "split-and-write" operation.</p>
<p>When I solved this problem, my <code>fill_table/5</code> function took these
arguments:</p>
<ul>
<li><p>The name of the table (an atom)</p></li>
<li><p>The name of the file to read (a string)</p></li>
<li><p>The function that adds the data (a higher-order <code>fun</code>)</p></li>
<li><p>The <code>record_info</code> for the field</p></li>
<li><p>The type of table. The phone call data is a <code>bag</code>, the
customer data is a <code>set</code>.</p></li>
</ul>
</section>






<section class="sect2" data-type="sect2" id="_part_three_2">
<h2>Part Three</h2>
<p>Write a function named <code>summary/3</code> that takes a last name, first name,
and middle name. It produces a tuple that contains the person&#8217;s phone number,
total number of minutes, and total cost for those minutes.</p>
<p>Here is some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(phone_mnesia).
{ok,phone_mnesia}
2&gt; phone_mnesia:setup("call_data.csv", "customer_data.csv").
{atomic,ok}
3&gt; phone_mnesia:summary("Smith", "Samuel", "Steven").
[{"838-555-1099",9,0.9}]
4&gt; phone_mnesia:summary("Nakamura", "Noriko", "").
[{"213-555-0172",9,1.08}]</pre>
<p>As promised, here&#8217;s the good news about query list comprehensions.
In this module, you need to access the
customer table to match the phone number to the name when collecting the
calls for the customer. You also need to access the customer table in
order to access the customer&#8217;s rate per minute. You don&#8217;t want to have
to write the specification for the guards on the customer table twice.</p>
<p>As
<a href="http://shop.oreilly.com/product/0636920025818.do">Introducing Erlang</a>
notes, "you can use the <code>qlc:q</code> function to hold a
list comprehension and the <code>qlc:e</code> function to process it." Specifically,
the <code>qlc:q</code> function returns a <em>query handle</em> which you can evaluate
and which you can also use in place of a list name in a query list
comprehension.</p>
<p>Here&#8217;s an example. Let&#8217;s say you have tables of people and their pets.
In the <code>pet</code> table, the <code>owner_id</code> references the <code>id_number</code> of someone
in the <code>person</code> table.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-record(person,
  {id_number, name, age, gender, city, amount_owed}).
-record(animal,
  {id_number, name, species, gender, owner_id}).</pre>
<p>You could do a query like this to find a
specific set of people, and then to find information about their pets:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">get_info() -&gt;
  People = mnesia:transaction(
    fun() -&gt; qlc:e(
      qlc:q( [ P ||
        P &lt;- mnesia:table(person),
        P#person.age &gt;= 21,
        P#person.gender == "M",
        P#person.city == "Podunk"]
        )
      )
    end
  ),

  Pets = mnesia:transaction(
    fun() -&gt; qlc:e(
      qlc:q( [{A#animal.name, A#animal.species, P#person.name} ||
        P &lt;- mnesia:table(person),
        P#person.age &gt;= 21,
        P#person.gender == "M",
        P#person.city == "Podunk",
        A &lt;- mnesia:table(animal),
        A#animal.owner_id == P#person.id_number])
      )
    end
  ),
  [People, Pets].</pre>
<p>To avoid duplicating the list and guards for the person table, you can make a
query list handle for that query and use it again in the animal search. Note
that you don&#8217;t have to be in a transacation to create a query handle,
but you must be in a transaction to process it.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">get_info_easier() -&gt;

  %% "Pre-process" the list comprehension for finding people

  QHandle = qlc:q( [ P ||
    P &lt;- mnesia:table(person),
    P#person.age &gt;= 21,
    P#person.gender == "M",
    P#person.city == "Podunk"]
  ),

  %% Evaluate it to retrieve the people you want

  People = mnesia:transaction(
    fun() -&gt; qlc:e( QHandle ) end
  ),

  %% And use the handle again when retrieving
  %% information about their pets

  Pets = mnesia:transaction(
    fun() -&gt; qlc:e(
      qlc:q( [{A#animal.name, A#animal.species, P#person.name} ||
        P &lt;- QHandle,
        A &lt;- mnesia:table(animal),
        A#animal.owner_id == P#person.id_number])
      )
    end
  ),
  [People, Pets].</pre>
<p><a data-type="xref" href="#SOLUTION10-ET02">See a suggested solution in Appendix A.</a></p>
</section>


</section>



</section>






<section data-type="chapter" id="OTP">
<h1>Getting Started with OTP</h1>
<p>In order to help me understand how the <code>gen_server</code> behavior works,
I drew the diagram shown in <a data-type="xref" href="#FIG1101">Processing a call in <code>gen_server</code></a>.</p>
<figure id="FIG1101">
<figcaption><span data-type="label">Figure 1-1. </span>Processing a call in <code>gen_server</code></figcaption>
<img src="images/eter_1101.png" alt="eter 1101"/>
</figure>
<p>The client does a <code>gen_server:call(Server, Request)</code>. The server will
then call the <code>handle_call/3</code> function that you have provided in the
<code>Module</code> that you told <code>gen_server</code> to use. <code>gen_server</code> will send your
module the client&#8217;s <code>Request</code>, an identifier telling who the request is
<code>From</code>, and the server&#8217;s current <code>State</code>.</p>
<p>Your <code>handle_call/3</code> function will fulfill the client&#8217;s <code>Request</code> and
send a <code>{reply, Reply, NewState}</code> tuple back to the server. It, in turn,
will send the <code>Reply</code> back to the client, and use the <code>NewState</code> to update
its state.</p>
<p>In <em>Introducing Erlang</em> and in the next two études,
the client is you, using the shell. The module that handles the
client&#8217;s call is contained within the same module as the <code>gen_server</code>
framework, but, as the preceding diagram shows, it does not have to be.</p>
<div data-type="note" class="note">
You can learn more about working with OTP basics in Chapters 11 and 12 of <em>Erlang Programming</em>, Chapters 16 and 18 of <em>Programming Erlang</em>, Chapter 4 of <em>Erlang and OTP in Action</em>, and Chapters 14 through 20 of <em>Learn You Some Erlang For Great Good!</em>.
</div>



<section class="sect1" data-type="sect1" id="CH11-ET01">
<h1>Étude 11-1: Get the Weather</h1>
<p>In this étude, you will create a weather server using the <code>gen_server</code>
OTP behavior.This server will handle requests using a four-letter weather
station identifier and will return a brief summary of the weather. You may
also ask the server for a list of most recently accessed weather stations.</p>
<p>Here is some sample output:</p>
<pre data-type="programlisting" class="programlisting">1&gt; c(weather).
{ok,weather}
2&gt; weather:start_link().
{ok,&lt;0.42.0&gt;}
3&gt; gen_server:call(weather, "KSJC").
{ok,[{location,"San Jose International Airport, CA"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 13:53:00 -0800"},
     {weather,"Overcast"},
     {temperature_string,"51.0 F (10.6 C)"}]}
4&gt; gen_server:call(weather, "KITH").
{ok,[{location,"Ithaca / Tompkins County, NY"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 16:56:00 -0500"},
     {weather,"A Few Clouds"},
     {temperature_string,"29.0 F (-1.6 C)"}]}
5&gt; gen_server:call(weather,"NONE").
{error,404}
6&gt; gen_server:cast(weather, "").
Most recent requests: ["KITH","KSJC"]</pre>




<section class="sect2" data-type="sect2" id="_obtaining_weather_data">
<h2>Obtaining Weather Data</h2>
<p>To retrieve a web page, you must first call <code>inets:start/0</code>; you will
want to do this in your <code>init/1</code> code. Then, simply call
<code>httpc:request(<em>url</em>)</code>, where <code><em>url</em></code> is a string containing the URL
you want. In this case, you will use the
server provided by <a href="http://www.noaa.gov/">National Oceanic and Atmospheric Administration</a>. This server accepts four-letter
weather station codes and returns an
XML file summarizing the current weather at that station. You request
this data with a URL in the form</p>
<p><code><a href="http://w1.weather.gov/xml/current_obs/">http://w1.weather.gov/xml/current_obs/</a><em>NNNN</em>.xml</code></p>
<p>where <code><em>NNNN</em></code> is the station code.</p>
<p>If the call to <code>httpc:request/1</code> fails you will get a tuple of the form
<code>{error,<em>information</em>}</code>.</p>
<p>If it succeeds, you will get a tuple in the form:</p>
<pre data-type="programlisting" class="programlisting">{ok,{{"HTTP/1.1",<em>code</em>,"<em>code message</em>"},
     [{"<em>HTTP header attribute</em>","<em>value</em>"},
      {"<em>Another attribute</em>","<em>another value</em>"}],
     "<em>page contents</em>"}}</pre>
<p>where <code><em>code</em></code> is the return code (200 means the page was found,
404 means it&#8217;s missing, anything else is some sort of error).</p>
<p>So, let&#8217;s say you have successfully retrieved a station&#8217;s data. You will
then get page content that contains something like this:</p>
<pre data-type="programlisting" class="programlisting">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;?xml-stylesheet href="latest_ob.xsl" type="text/xsl"?&gt;
&lt;current_observation version="1.0"
	 xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	 xsi:noNamespaceSchemaLocation="http://www.weather.gov/view/current_observation.xsd"&gt;
	&lt;credit&gt;NOAA's National Weather Service&lt;/credit&gt;
	&lt;credit_URL&gt;http://weather.gov/&lt;/credit_URL&gt;
	&lt;image&gt;
		&lt;url&gt;http://weather.gov/images/xml_logo.gif&lt;/url&gt;
		&lt;title&gt;NOAA's National Weather Service&lt;/title&gt;
		&lt;link&gt;http://weather.gov&lt;/link&gt;
	&lt;/image&gt;
	&lt;suggested_pickup&gt;15 minutes after the hour&lt;/suggested_pickup&gt;
	&lt;suggested_pickup_period&gt;60&lt;/suggested_pickup_period&gt;
	&lt;location&gt;San Jose International Airport, CA&lt;/location&gt;
	&lt;station_id&gt;KSJC&lt;/station_id&gt;
	&lt;latitude&gt;37.37&lt;/latitude&gt;
	&lt;longitude&gt;-121.93&lt;/longitude&gt;
	&lt;observation_time&gt;Last Updated on Feb 18 2013, 11:53 am PST&lt;/observation_time&gt;
  &lt;observation_time_rfc822&gt;Mon, 18 Feb 2013 11:53:00 -0800&lt;/observation_time_rfc822&gt;
	&lt;weather&gt;Overcast&lt;/weather&gt;
	&lt;temperature_string&gt;50.0 F (10.0 C)&lt;/temperature_string&gt;
	&lt;temp_f&gt;50.0&lt;/temp_f&gt;
	&lt;temp_c&gt;10.0&lt;/temp_c&gt;
	&lt;relative_humidity&gt;77&lt;/relative_humidity&gt;
	&lt;wind_string&gt;Calm&lt;/wind_string&gt;
	&lt;wind_dir&gt;North&lt;/wind_dir&gt;
	&lt;wind_degrees&gt;0&lt;/wind_degrees&gt;
	&lt;wind_mph&gt;0.0&lt;/wind_mph&gt;
	&lt;wind_kt&gt;0&lt;/wind_kt&gt;
	&lt;pressure_string&gt;1017.7 mb&lt;/pressure_string&gt;
	&lt;pressure_mb&gt;1017.7&lt;/pressure_mb&gt;
	&lt;pressure_in&gt;30.05&lt;/pressure_in&gt;
	&lt;dewpoint_string&gt;43.0 F (6.1 C)&lt;/dewpoint_string&gt;
	&lt;dewpoint_f&gt;43.0&lt;/dewpoint_f&gt;
	&lt;dewpoint_c&gt;6.1&lt;/dewpoint_c&gt;
	&lt;visibility_mi&gt;10.00&lt;/visibility_mi&gt;
 	&lt;icon_url_base&gt;http://forecast.weather.gov/images/wtf/small/&lt;/icon_url_base&gt;
	&lt;two_day_history_url&gt;http://www.weather.gov/data/obhistory/KSJC.html&lt;/two_day_history_url&gt;
	&lt;icon_url_name&gt;ovc.png&lt;/icon_url_name&gt;
	&lt;ob_url&gt;http://www.weather.gov/data/METAR/KSJC.1.txt&lt;/ob_url&gt;
	&lt;disclaimer_url&gt;http://weather.gov/disclaimer.html&lt;/disclaimer_url&gt;
	&lt;copyright_url&gt;http://weather.gov/disclaimer.html&lt;/copyright_url&gt;
	&lt;privacy_policy_url&gt;http://weather.gov/notice.html&lt;/privacy_policy_url&gt;
&lt;/current_observation&gt;</pre>
</section>






<section class="sect2" data-type="sect2" id="_parsing_the_data">
<h2>Parsing the Data</h2>
<p>You now have to parse that XML data. Luckily, Erlang comes with the
<code>xmerl_scan:string/1</code> function, which will parse your XML into a rather
imposing-looking tuple. Here is what it looks like for a very simple
bit of XML:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; XML = "&lt;pets&gt;&lt;cat&gt;Misha&lt;/cat&gt;&lt;dog&gt;Lady&lt;/dog&gt;&lt;/pets&gt;".
"&lt;pets&gt;&lt;cat&gt;Misha&lt;/cat&gt;&lt;dog&gt;Lady&lt;/dog&gt;&lt;/pets&gt;"
3&gt; Result = xmerl_scan:string(XML).
{{xmlElement,pets,pets,[],
     {xmlNamespace,[],[]},
     [],1,[],
     [{xmlElement,cat,cat,[],
                  {xmlNamespace,[],[]},
                  [{pets,1}],
                  1,[],
                  [{xmlText,[{cat,1},{pets,1}],1,[],"Misha",text}],
                  [],
                  "/home/david/etudes/code/ch11-01",
                  undeclared},
      {xmlElement,dog,dog,[],
                  {xmlNamespace,[],[]},
                  [{pets,1}],
                  2,[],
                  [{xmlText,[{dog,2},{pets,1}],1,[],"Lady",text}],
                  [],undefined,undeclared}],
     [],
     "/home/david/etudes/code/ch11-01",
     undeclared},
     []}</pre>
<p>Ye cats! How you do work with that?! First, put this at the top of your
code so that you can use <code>xmerl</code>'s record definitions:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-include_lib("xmerl/include/xmerl.hrl").</pre>
<p>You can see all the details of the records at
<a href="http://erlang.googlecode.com/svn-history/r160/trunk/lib/xmerl/include/xmerl.hrl">http://erlang.googlecode.com/svn-history/r160/trunk/lib/xmerl/include/xmerl.hrl</a></p>
<p>Then, copy and paste this into your code. You could figure it out
on your own, but that would take away from setting up the server, which is
the whole point of this étude.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% Take raw XML data and return a set of {key, value} tuples

analyze_info(WebData) -&gt;
  %% list of fields that you want to extract
  ToFind = [location, observation_time_rfc822, weather, temperature_string],

  %% get just the parsed data from the XML parse result
  Parsed = element(1, xmerl_scan:string(WebData)),

  %% This is the list of all children under &lt;current_observation&gt;
  Children = Parsed#xmlElement.content,

  %% Find only XML elements and extract their names and their text content.
  %% You need the guard so that you don't process the newlines in the
  %% data (they are XML text descendants of the root element).
  ElementList = [{El#xmlElement.name, extract_text(El#xmlElement.content)}
    || El &lt;- Children, element(1, El) == xmlElement],

  %% ElementList is now a keymap; get the data you want from it.
  lists:map(fun(Item) -&gt; lists:keyfind(Item, 1, ElementList) end, ToFind).


%% Given the parsed content of an XML element, return its first node value
%% (if it's a text node); otherwise return the empty string.

extract_text(Content) -&gt;
  Item = hd(Content),
  case element(1, Item) of
    xmlText -&gt; Item#xmlText.value;
    _ -&gt; ""
  end.</pre>
</section>






<section class="sect2" data-type="sect2" id="_set_up_a_supervisor">
<h2>Set up a Supervisor</h2>
<p>Finally, you can easily crash the server by handing it a number instead
of a string for the station code.  Set up a supervisor to restart the
server when it crashes.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(weather_sup).
{ok,weather_sup}
2&gt; {ok, Pid} = weather_sup:start_link().
{ok,&lt;0.38.0&gt;}
3&gt; unlink(Pid).
true
4&gt; gen_server:call(weather, "KGAI").
{ok,[{location,"Montgomery County Airpark, MD"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 17:55:00 -0500"},
     {weather,"Fair"},
     {temperature_string,"37.0 F (3.0 C)"}]}
5&gt; gen_server:call(weather, 1234).
** exception exit: {{badarg,[{erlang,'++',[1234,".xml"],[]},
                             {weather,get_weather,2,[{file,"weather.erl"},{line,43}]},
                             {weather,handle_call,3,[{file,"weather.erl"},{line,23}]},
                             {gen_server,handle_msg,5,
                                         [{file,"gen_server.erl"},{line,588}]},
                             {proc_lib,init_p_do_apply,3,
                                       [{file,"proc_lib.erl"},{line,227}]}]},
                    {gen_server,call,[weather,1234]}}
     in function  gen_server:call/2 (gen_server.erl, line 180)

=INFO REPORT==== 18-Feb-2013::15:57:19 ===
    application: inets
    exited: stopped
    type: temporary
6&gt;
=ERROR REPORT==== 18-Feb-2013::15:57:19 ===
** Generic server weather terminating
** Last message in was 1234
** When Server state == ["KGAI"]
** Reason for termination ==
** {badarg,[{erlang,'++',[1234,".xml"],[]},
            {weather,get_weather,2,[{file,"weather.erl"},{line,43}]},
            {weather,handle_call,3,[{file,"weather.erl"},{line,23}]},
            {gen_server,handle_msg,5,[{file,"gen_server.erl"},{line,588}]},
            {proc_lib,init_p_do_apply,3,[{file,"proc_lib.erl"},{line,227}]}]}

6&gt; gen_server:call(weather, "KCMI").
{ok,[{location,"Champaign / Urbana, University of Illinois-Willard, IL"},
     {observation_time_rfc822,"Mon, 18 Feb 2013 16:53:00 -0600"},
     {weather,"Overcast and Breezy"},
     {temperature_string,"47.0 F (8.3 C)"}]}</pre>
<p><a data-type="xref" href="#SOLUTION11-ET01">See a suggested solution in Appendix A.</a></p>
</section>


</section>






<section class="sect1" data-type="sect1" id="CH11-ET02">
<h1>Étude 11-2: Wrapper Functions</h1>
<p>In the previous étude, you made calls directly to <code>gen_server</code>. This is
great for experimentation, but in a real application, you do not want
other modules to have to know the exact format of the arguments you gave
to <code>gen_server:call/2</code> or <code>gen_server:cast/2</code>. Instead, you provide a
"wrapper" function that makes the actual call. In this way, you can change
the internal format of your server requests while the interface you present
to other users remains unchanged.</p>
<p>In this étude, then, you will provide two wrapper functions
<code>report/1</code> and <code>recent/0</code>. The <code>report/1</code> function will take a station name
as its argument and do the appropriate <code>gen_server:call</code>; the
<code>recent/0</code> function will do an appropriate <code>gen_server:cast</code>. Everything
else in your code will remain unchanged. You will, of course, have to add
<code>report/1</code> and <code>recent/0</code> to the <code>-export</code> list.</p>
<p>Here&#8217;s some sample output.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">1&gt; c(weather).
{ok,weather}
2&gt; weather:start_link().
{ok,&lt;0.45.0&gt;}
3&gt; weather:report("KSJC").
{ok,[{location,"San Jose International Airport, CA"},
     {observation_time_rfc822,"Tue, 26 Feb 2013 17:53:00 -0800"},
     {weather,"Fair"},
     {temperature_string,"56.0 F (13.3 C)"}]}
4&gt; weather:report("XYXY").
{error,404}
5&gt; weather:report("KCMI").
{ok,[{location,"Champaign / Urbana, University of Illinois-Willard, IL"},
     {observation_time_rfc822,"Tue, 26 Feb 2013 19:53:00 -0600"},
     {weather,"Light Rain Fog/Mist"},
     {temperature_string,"34.0 F (1.1 C)"}]}
6&gt; weather:recent().
Most recent requests: ["KCMI","KSJC"]</pre>
<p><a data-type="xref" href="#SOLUTION11-ET02">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH11-ET03">
<h1>Étude 11-3: Independent Server and Client</h1>
<p>In the previous études, the client and server have been running in
the same shell. In this étude, you will make the server available to
clients running in other shells.</p>
<p>To make a node available to other nodes, you need to name the node by using
the <code>-name</code> option when starting <code>erl</code>. It looks like this:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">michele@localhost $ erl -name serverNode
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(serverNode@localhost.gateway.2wire.net)1&gt;</pre>
<p>This is a <em>long name</em>. You can also set up a node with a short name by using
the <code>-sname</code> option:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">michele@localhost $ erl -sname serverNode
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(serverNode@localhost)1&gt;</pre>
<div data-type="warning" class="warning">
If you set up a node in this way, <em>any</em> other node can connect
to it and do any shell commands at all. In order to prevent this,
you may use the <code>-setcookie <em>Cookie</em></code> when starting <code>erl</code>. Then,
only nodes that have the same <em>Cookie</em> (which is an atom) can
connect to your node.
</div>
<p>To connect to a node, use the <code>net_adm:ping/1</code> function, and give it
the name of the server you want to connect to as its argument. If you
connect succesfully, the function will return the atom <code>pong</code>; otherwise,
it will return <code>pang</code>.</p>
<p>Here is an example. First, start a shell with a (very bad) secret
cookie:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">michele@localhost $ erl -sname serverNode -setcookie chocolateChip
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(serverNode@localhost)1&gt;</pre>
<p>Now, open another terminal window, start a shell with a different
cookie, and try to connect to the server node. I have purposely used
a different user name to show that this works too.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">steve@localhost $ erl -sname clientNode -setcookie oatmealRaisin
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(clientNode@localhost)1&gt; net_adm:ping(serverNode@localhost).
pang</pre>
<p>The server node will detect this attempt and let you know about it:</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">=ERROR REPORT==== 28-Feb-2013::22:41:38 ===
** Connection attempt from disallowed node clientNode@localhost **</pre>
<p>Quit the client shell, and restart it with a matching cookie, and
all will be well.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">steve@localhost erltest $ erl -sname clientNode -setcookie chocolateChip
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(clientNode@localhost)1&gt; net_adm:ping(serverNode@localhost).
pong</pre>
<p>To make your weather report server available to other nodes, you
need to do these things:</p>
<ul>
<li><p>In the <code>start_link/0</code> convenience method, set the first argument to
<code>gen_server:start_link/4</code> to <code>{global, ?SERVER}</code> instead of
<code>{local, ?SERVER}</code></p></li>
<li><p>In calls to <code>gen_server:call/2</code> and <code>gen_server:cast/2</code>, replace the
module name <code>weather</code> with <code>{global, weather}</code></p></li>
<li><p>Add a <code>connect/1</code> function that takes the server node name as its
argument. This function will use <code>net_adm:ping/1</code> to attempt to contact
the server. It provides appropriate feedback when it succeeds or fails.</p></li>
</ul>
<p>Here is what it looks like when one user starts the server in a shell.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">michele@localhost $ erl -sname serverNode -setcookie meteorology
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(serverNode@localhost)1&gt; weather:start_link().
{ok,&lt;0.39.0&gt;}</pre>
<p>And here&#8217;s another user in a different shell, calling upon the server.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">steve@localhost $ erl -sname clientNode -setcookie meteorology
Erlang R15B02 (erts-5.9.2) [source] [smp:2:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.2  (abort with ^G)
(clientNode@localhost)1&gt; weather:connect(serverNode@localhost).
Connected to server.
ok
(clientNode@localhost)2&gt; weather:report("KSJC").
{ok,[{location,"San Jose International Airport, CA"},
     {observation_time_rfc822,"Thu, 28 Feb 2013 21:53:00 -0800"},
     {weather,"Fair"},
     {temperature_string,"52.0 F (11.1 C)"}]}
(clientNode@localhost)3&gt; weather:report("KITH").
{ok,[{location,"Ithaca / Tompkins County, NY"},
     {observation_time_rfc822,"Fri, 01 Mar 2013 00:56:00 -0500"},
     {weather,"Light Snow"},
     {temperature_string,"31.0 F (-0.5 C)"}]}
(clientNode@localhost)4&gt; weather:recent().
ok</pre>
<p>Whoa! What happened to the output from that last call?
The problem is that the <code>weather:recent/0</code> call does
an <code>io:format/3</code> call; that output will go to the server shell, since the
server is running that code, not the client. Bonus points if you fix this
problem by changing <code>weather:recent/0</code> from using
<code>gen_server:cast/2</code> to use <code>gen_server:call/2</code> instead to return
the recently reported weather stations as its reply.</p>
<p>There&#8217;s one more question that went through my mind after I implemented
my solution: how did I know that the client was calling the <code>weather</code> code
running on the server and not the <code>weather</code> code in its own shell? It was
easy to find out: I stopped the server.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">(serverNode@localhost)2&gt;
User switch command
 --&gt; q
michele@localhost $</pre>
<p>Then I had the client try to get a weather report.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">(clientNode@localhost)5&gt; weather:report("KSJC").
** exception exit: {noproc,{gen_server,call,[{global,weather},"KSJC"]}}
     in function  gen_server:call/2 (gen_server.erl, line 180)</pre>
<p>The fact that it failed told me that yes, indeed, the client was getting its
information from the server.</p>
<p><a data-type="xref" href="#SOLUTION11-ET03">See a suggested solution in Appendix A.</a></p>
</section>






<section class="sect1" data-type="sect1" id="CH11-ET04">
<h1>Étude 11-4: Chat Room</h1>
<p>In the previous études, the client simply made a call to the server, and
didn&#8217;t do any processing of its own. In this étude, you will create a
"chat room" with a chat server and multiple clients, much as you see in
<a data-type="xref" href="#FIG1102">Server with multiple clients</a>.</p>
<figure id="FIG1102">
<figcaption><span data-type="label">Figure 1-2. </span>Server with multiple clients</figcaption>
<img src="images/eter_1102.png" alt="eter 1102"/>
</figure>
<p>The interesting part of this program is that the client will <em>also</em> be
a <code>gen_server</code>, as shown in <a data-type="xref" href="#FIG1103">Client as a <code>gen_server</code></a>.</p>
<figure id="FIG1103">
<figcaption><span data-type="label">Figure 1-3. </span>Client as a <code>gen_server</code></figcaption>
<img src="images/eter_1103.png" alt="eter 1103"/>
</figure>
<p>Up until now, you have been using a module name as the first argument to
<code>gen_server:call/2</code>, and in the previous étude, you used
<code>net_adm:ping/1</code> to connect to a server.</p>
<p>In this étude, you won&#8217;t need <code>net_adm:ping/1</code>. Instead,
you will use a tuple of the form
<code>{Module, Node}</code> to directly connect to the node you want. So, for
example, if you want to make a call to a module named <code>chatroom</code> on
a node named <code>lobby@localhost</code>, you would do something like this:</p>
<p><code>gen_server:call({chatroom, lobby@localhost}, Request)</code></p>
<p>This means
you won&#8217;t need to connect with <code>net_adm:ping/1</code>.</p>
<p>Here is my design for the solution. You, of course, may come up
with an entirely different and better design.</p>
<p>My solution has two modules, both of which use the <code>gen_server</code> behavior.</p>




<section class="sect2" data-type="sect2" id="_the_code_chatroom_code_module">
<h2>The <code>chatroom</code> Module</h2>
<p>The first module, <code>chatroom</code>, will keep as its state a list of tuples, one
tuple for each person in the chat. Each tuple has the format
<code>{{UserName, UserServer}, Pid}</code>. The Pid is the one that <code>gen_server:call</code>
receives in the <code>From</code> parameter; it&#8217;s guaranteed to be unique for each
person in chat.</p>
<p>The <code>handle_call/3</code> function will accept the following requests.</p>

<dl>
<dt><code>{login, UserName, ServerName}</code></dt>
<dd><p>Adds the user name, server name, and Pid (which is in the <code>From</code> parameter)
to the server&#8217;s state. Don&#8217;t allow a duplicate user name from the same server.</p></dd>
<dt><code>logout</code></dt>
<dd><p>Removes the user from the state list.</p></dd>
<dt><code>{say, Text}</code></dt>
<dd><p>Sends the given Text to all the other users in the chat room. Use
<code>gen_server:cast/2</code> to send the message.</p></dd>
<dt><code>users</code></dt>
<dd><p>Returns the list of names and servers for all people currently in the
chat room.</p></dd>
<dt><code>{who, Person, ServerName}</code></dt>
<dd><p>Return the profile of the given person/server. (This is "extra credit";
see the following details about the <code>person</code> module). It works by
calling the <code>person</code> module at <code>ServerName</code> and giving it a
<code>get_profile</code> request.</p></dd>
</dl>
</section>






<section class="sect2" data-type="sect2" id="_the_code_person_code_module">
<h2>The <code>person</code> Module</h2>
<p>The other module, <code>person</code>, has a <code>start_link/1</code> function; the argument
is the node name of the chat room server. This will be passed on to the
<code>init/1</code> function. This is stored in the server&#8217;s state. I did this because
many other calls need to know the chat room server&#8217;s name, and keeping it in the
person&#8217;s state seemed a reasonable choice.</p>
<p>For extra credit, the state will also include the person&#8217;s profile, which
is a list of <code>{Key, Value}</code> tuples.</p>
<p>The <code>handle_call/3</code> takes care of these requests:</p>

<dl>
<dt><code>get_chat_node</code></dt>
<dd><p>Returns the chat node name that&#8217;s stored in the server&#8217;s state. (Almost all of
the wrapper functions to be described in the following section will need
the chat node name.)</p></dd>
<dt><code>get_profile</code></dt>
<dd><p>Returns the profile that&#8217;s stored in the server&#8217;s state (extra credit)</p></dd>
<dt><code>{set_profile, Key, Value}</code></dt>
<dd><p>If the profile already contains the key, replace it with the given value.
Otherwise, add the key and value to the profile. Hint: use
<code>lists:keymember/3</code> and <code>lists:keyreplace/4</code>. (extra credit)</p></dd>
</dl>
<p>Because the chat room server uses <code>gen_server:cast/2</code> to send messages
to the people in the room, your <code>handle_cast/3</code> function will receive messages sent from other users in this form:</p>
<p><code>{message, {FromUser, FromServer}, Text}</code></p>
</section>






<section class="sect2" data-type="sect2" id="_wrapper_functions_for_the_code_person_code_module">
<h2>Wrapper Functions for the <code>person</code> module</h2>

<dl>
<dt><code>get_chat_node()</code></dt>
<dd><p>A convenience function to get the name of the chat host node by doing
<code>gen_server:call(person, get_chat_node)</code></p></dd>
<dt><code>login(UserName)</code></dt>
<dd><p>Calls the chat room server with a {login, UserName} request. If the
user name is an atom, use <code>atom_to_list/1</code> to convert it to a string.</p></dd>
<dt><code>logout()</code></dt>
<dd><p>Calls the chat room server with a <code>logout</code> request. As you saw in the
description of <code>chatroom</code>, the server uses the process ID to figure out
who should be logged out.</p></dd>
<dt><code>say(Text)</code></dt>
<dd><p>Calls the chat server with a <code>{say, Text}</code> request.</p></dd>
<dt><code>users()</code></dt>
<dd><p>Calls the chat server with a <code>users</code> request.</p></dd>
<dt><code>who(UserName, UserNode)</code></dt>
<dd><p>Calls the chat server with a <code>{who, UserName, UserNode}</code> request to
see the profile of the given person. (extra credit)</p></dd>
<dt><code>set_profile(Key, Value)</code></dt>
<dd><p>A convenience method that calls the <code>person</code> module with a
<code>{set_profile, Key, Value}</code> request. (extra credit)</p></dd>
</dl>
<div data-type="note" class="note">
<p>The <code>login/2</code>, <code>logout/0</code>, and <code>say/2</code> wrapper functions do <em>not</em> call
the chat server directly, because the <code>from</code> pid would be the process
calling those functions (usually the shell),
not the person server. Instead, these functions will make a
<code>gen_server:call</code> to the <code>person</code> server. Its <code>handle_call</code>
function will forward the <code>gen_server:call</code> to the <code>chatroom</code>. That way, the
chat room server sees the request coming from the <code>person</code> server.</p>
</div>
</section>






<section class="sect2" data-type="sect2" id="_putting_it_all_together">
<h2>Putting it All Together</h2>
<p>Here is what the chat room server looks like. The lines beginning with
<code>Recipient list:</code> are debug output. I have gotten rid of the startup lines
from the <code>erl</code> command.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">erl -sname lobby

(lobby@localhost)1&gt; chatroom:start_link().
{ok,&lt;0.39.0&gt;}
Recipient list: [{"Steve",sales@localhost},{"Michele",marketing@localhost}]
Recipient list: [{"David",engineering@localhost},
                 {"Michele",marketing@localhost}]
Recipient list: [{"David",engineering@localhost},{"Steve",sales@localhost}]
Recipient list: [{"David",engineering@localhost},
                 {"Michele",marketing@localhost}]</pre>
<p>And here are three other servers talking to one another and setting
profile information.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">erl -sname sales

(sales@localhost)1&gt; person:start_link(lobby@localhost).
Chat node is: lobby@localhost
{ok,&lt;0.39.0&gt;}
(sales@localhost)2&gt; person:login("Steve").
{ok,"Logged in."}
(sales@localhost)3&gt; person:set_profile(city, "Chicago").
{ok,[{city,"Chicago"}]}
David (engineering@localhost) says: "Hi, everyone."
(sales@localhost)4&gt; person:say("How's things in Toronto, David?").
ok
Michele (marketing@localhost) says: "New product launch is next week."
(sales@localhost)5&gt; person:say("oops, gotta run.").
ok
(sales@localhost)6&gt; person:logout().
ok</pre>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">erl -sname engineering

(engineering@localhost)1&gt; person:start_link(lobby@localhost).
Chat node is: lobby@localhost
{ok,&lt;0.39.0&gt;}
(engineering@localhost)2&gt; person:login("David").
{ok,"Logged in."}
(engineering@localhost)3&gt; person:set_profile(city, "Toronto").
{ok,[{city,"Toronto"}]}
(engineering@localhost)4&gt; person:set_profile(department, "New Products").
{ok,[{department,"New Products"},{city,"Toronto"}]}
(engineering@localhost)5&gt; person:say("Hi, everyone.").
ok
Steve (sales@localhost) says: "How's things in Toronto, David?"
Michele (marketing@localhost) says: "New product launch is next week."
(engineering@localhost)6&gt; person:users().
[{"David",engineering@localhost},
 {"Steve",sales@localhost},
 {"Michele",marketing@localhost}]
Steve (sales@localhost) says: "oops, gotta run."</pre>
<pre data-type="programlisting" class="programlisting" data-code-language="erl">erl -sname marketing

(marketing@localhost)1&gt; person:start_link(lobby@localhost).
Chat node is: lobby@localhost
{ok,&lt;0.39.0&gt;}
(marketing@localhost)2&gt; person:login("Michele").
{ok,"Logged in."}
(marketing@localhost)3&gt; person:set_profile(city, "San Jose").
{ok,[{city,"San Jose"}]}
David (engineering@localhost) says: "Hi, everyone."
Steve (sales@localhost) says: "How's things in Toronto, David?"
(marketing@localhost)4&gt; person:say("New product launch is next week.").
ok
Steve (sales@localhost) says: "oops, gotta run."
(marketing@localhost)5&gt; person:users().
[{"David",engineering@localhost},
 {"Michele",marketing@localhost}]</pre>
<p><a data-type="xref" href="#SOLUTION11-ET04">See a suggested solution in Appendix A.</a></p>
</section>


</section>



</section>






<section data-type="chapter" id="contributors">
<h1>Contributors</h1>
<p>The author and O&#8217;Reilly Media wish to thank the people who have contributed to this project. They include:</p>
<ul>
<li><p><a href="https://github.com/draconar">Fabio "Draco" Fonseca</a></p></li>
<li><p><a href="https://github.com/develop7">Andrei Dziahel</a></p></li>
<li><p><a href="https://github.com/alco">Alexei Sholik</a></p></li>
<li><p><a href="https://github.com/braindump">Lars Herbach</a></p></li>
</ul>
</section>






<section class="appendix" data-type="appendix" id="APPENDIX">
<h1>Solutions to Études</h1>
<p>Here are the solutions that I came up with for the études in
this book. Since I was learning Erlang as I wrote them, you
may expect some of the code to be naïve in the extreme.</p>



<section class="sect1" data-type="sect1" id="SOLUTION02-ET01">
<h1>Solution 2-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH02-ET01">Étude 2-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(geom).
-export([area/2]).

area(L,W) -&gt; L * W.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION02-ET02">
<h1>Solution 2-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH02-ET02">Étude 2-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_2">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/2]).

%% @doc Calculates the area of a rectangle, given the
%% length and width. Returns the product
%% of its arguments.

-spec(area(number(),number()) -&gt; number()).

area(L,W) -&gt; L * W.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION02-ET03">
<h1>Solution 2-3</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH02-ET03">Étude 2-3</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_3">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/2]).

%% @doc Calculates the area of a rectangle, given the
%% length and width. Returns the product
%% of its arguments.

-spec(area(number(),number()) -&gt; number()).

area(L,W) -&gt; L * W.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION03-ET01">
<h1>Solution 3-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH03-ET01">Étude 3-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_4">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/3]).

%% @doc Calculates the area of a shape, given the
%% shape and two of the dimensions. Returns the product
%% of its arguments for a rectangle, one half the
%% product of the arguments for a triangle, and
%% math:pi times the product of the arguments for
%% an ellipse.

-spec(area(atom(), number(),number()) -&gt; number()).

area(rectangle, L,W) -&gt; L * W;

area(triangle, B, H) -&gt; (B * H) / 2.0;

area(ellipse, A, B) -&gt; math:pi() * A * B.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION03-ET02">
<h1>Solution 3-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH03-ET02">Étude 3-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_5">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/3]).

%% @doc Calculates the area of a shape, given the
%% shape and two of the dimensions. Returns the product
%% of its arguments for a rectangle, one half the
%% product of the arguments for a triangle, and
%% math:pi times the product of the arguments for
%% an ellipse. Ensure that both arguments are greater than
%% or equal to zero.

-spec(area(atom(), number(),number()) -&gt; number()).

area(rectangle, L,W) when L &gt;=0, W &gt;= 0 -&gt; L * W;

area(triangle, B, H) when B&gt;= 0, H &gt;= 0 -&gt; (B * H) / 2.0;

area(ellipse, A, B) when A &gt;= 0, B &gt;= 0 -&gt; math:pi() * A * B.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION03-ET03">
<h1>Solution 3-3</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH03-ET03">Étude 3-3</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_6">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/3]).

%% @doc Calculates the area of a shape, given the
%% shape and two of the dimensions. Returns the product
%% of its arguments for a rectangle, one half the
%% product of the arguments for a triangle, and
%% math:pi times the product of the arguments for
%% an ellipse. Invalid data returns zero.

-spec(area(atom(), number(),number()) -&gt; number()).

area(rectangle, L,W) when L &gt;=0, W &gt;= 0 -&gt; L * W;

area(triangle, B, H) when B&gt;= 0, H &gt;= 0 -&gt; (B * H) / 2.0;

area(ellipse, A, B) when A &gt;= 0, B &gt;= 0 -&gt; math:pi() * A * B;

area(_, _, _) -&gt; 0.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION03-ET04">
<h1>Solution 3-4</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH03-ET04">Étude 3-4</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_7">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/1]).

%% @doc Calculates the area of a shape, given a tuple
%% containing a shape and two of the dimensions.
%% Works by calling a private function.

-spec(area({atom(), number(),number()}) -&gt; number()).

area({Shape, Dim1, Dim2}) -&gt; area(Shape, Dim1, Dim2).

%% @doc Returns the product of its arguments for a rectangle,
%% one half the product of the arguments for a triangle,
%% and math:pi times the product of the arguments for
%% an ellipse. Invalid data returns zero.

-spec(area(atom(), number(),number()) -&gt; number()).

area(rectangle, L,W) when L &gt;=0, W &gt;= 0 -&gt; L * W;

area(triangle, B, H) when B&gt;= 0, H &gt;= 0 -&gt; (B * H) / 2.0;

area(ellipse, A, B) when A &gt;= 0, B &gt;= 0 -&gt; math:pi() * A * B;

area(_, _, _) -&gt; 0.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION04-ET01">
<h1>Solution 4-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH04-ET01">Étude 4-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_8">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/3]).

%% @doc Calculates the area of a shape, given the
%% shape and two of the dimensions. Returns the product
%% of its arguments for a rectangle, one half the
%% product of the arguments for a triangle, and
%% math:pi times the product of the arguments for
%% an ellipse.

-spec(area(atom(), number(),number()) -&gt; number()).

area(Shape, A, B) when A &gt;= 0, B &gt;= 0 -&gt;
  case Shape of
    rectangle -&gt; A * B;
    triangle -&gt; (A * B) / 2.0;
    ellipse -&gt; math:pi() * A * B
  end.</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION04-ET02">
<h1>Solution 4-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH04-ET02">Étude 4-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_dijkstra_erl_code">
<h2><code>dijkstra.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Recursive function for calculating GCD
%% of two numbers using Dijkstra's algorithm.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(dijkstra).
-export([gcd/2]).

%% @doc Calculates the greatest common divisor of two
%% integers. Uses Dijkstra's algorithm, which does not
%% require any division.

-spec(gcd(number(), number()) -&gt; number()).

gcd(M, N) -&gt;
  if
    M == N  -&gt; M;
    M &gt; N -&gt; gcd(M - N, N);
    true -&gt; gcd(M, N - M)
  end.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION04-ET02B">
<h1>Solution 4-2</h1>
<p>Here is another solution for
<a data-type="xref" href="#CH04-ET02">Étude 4-2</a>. This solution uses guards instead of
<code>if</code>.</p>




<section class="sect2" data-type="sect2" id="__code_dijkstra_erl_code_2">
<h2><code>dijkstra.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Recursive function for calculating GCD
%% of two numbers using Dijkstra's algorithm.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(dijkstra).
-export([gcd/2]).

%% @doc Calculates the greatest common divisor of two
%% integers. Uses Dijkstra's algorithm, which does not
%% require any division.

-spec(gcd(number(), number()) -&gt; number()).

gcd(M, N) when M == N -&gt;
  M;

gcd(M,N) when M &gt; N -&gt;
  gcd(M - N, N);

gcd(M, N) -&gt;
  gcd(M, N - M).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION04-ET03">
<h1>Solution 4-3</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH04-ET03">Étude 4-3</a>.</p>




<section class="sect2" data-type="sect2" id="__code_powers_erl_code">
<h2><code>powers.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for raising a number to an integer power
%% and finding the Nth root of a number using Newton's method.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(powers).
-export([raise/2]).

%% @doc Raise a number X to an integer power N.
%% Any number to the power 0 equals 1.
%% Any number to the power 1 is that number itself.
%% When N is positive, X^N is equal to X times X^(N - 1)
%% When N is negative, X^N is equal to 1.0 / X^N

-spec(raise(number(), integer()) -&gt; number()).

raise(_, 0) -&gt; 1;

raise(X, 1) -&gt; X;

raise(X, N) when N &gt; 0 -&gt; X * raise(X, N - 1);

raise(X, N) when N &lt; 0 -&gt; 1 / raise(X, -N).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_powers_traced_erl_code">
<h2><code>powers_traced.erl</code></h2>
<p>This code contains output that lets you see the progress
of the recursion.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for raising a number to an integer power
%% and finding the Nth root of a number using Newton's method.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(powers_traced).
-export([raise/2]).

%% @doc Raise a number X to an integer power N.
%% Any number to the power 0 equals 1.
%% Any number to the power 1 is that number itself.
%% When N is positive, X^N is equal to X times X^(N - 1)
%% When N is negative, X^N is equal to 1.0 / X^N

-spec(raise(number(), integer()) -&gt; number()).

raise(_, 0) -&gt; 1;

raise(X, 1) -&gt; X;

raise(X, N) when N &gt; 0 -&gt;
  io:format("Enter X: ~p, N: ~p~n", [X, N]),
  Result = X * raise(X, N - 1),
  io:format("Result is ~p~n", [Result]),
  Result;

raise(X, N) when N &lt; 0 -&gt; 1 / raise(X, -N).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION04-ET04">
<h1>Solution 4-4</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH04-ET04">Étude 4-4</a>.</p>




<section class="sect2" data-type="sect2" id="__code_powers_erl_code_2">
<h2><code>powers.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for raising a number to an integer power.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(powers).
-export([raise/2]).

%% @doc Raise a number X to an integer power N.
%% Any number to the power 0 equals 1.
%% Any number to the power 1 is that number itself.
%% When N is positive, X^N is equal to X times X^(N - 1)
%% When N is negative, X^N is equal to 1.0 / X^N

-spec(raise(number(), integer()) -&gt; number()).

raise(_, 0) -&gt; 1;

raise(X, N) when N &gt; 0 -&gt;
  raise(X, N, 1);

raise(X, N) when N &lt; 0 -&gt; 1 / raise(X, -N).

%% @doc Helper function to raise X to N by passing an Accumulator
%% from call to call.
%% When N is 0, return the value of the Accumulator;
%% otherwise return raise(X, N - 1, X * Accumulator)

raise(_, 0, Accumulator) -&gt; Accumulator;

raise(X, N, Accumulator) -&gt;
  raise(X, N-1, X * Accumulator).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_powers_traced_erl_code_2">
<h2><code>powers_traced.erl</code></h2>
<p>This code contains output that lets you see the progress
of the recursion.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for raising a number to an integer power.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(powers_traced).
-export([raise/2]).

%% @doc Raise a number X to an integer power N.
%% Any number to the power 0 equals 1.
%% Any number to the power 1 is that number itself.
%% When N is negative, X^N is equal to 1.0 / X^N
%% When N is positive, call raise/3 with 1 as the accumulator.

-spec(raise(number(), integer()) -&gt; number()).

raise(_, 0) -&gt; 1;

raise(X, N) when N &gt; 0 -&gt;
  raise(X, N, 1);

raise(X, N) when N &lt; 0 -&gt; 1 / raise(X, -N).

%% @doc Helper function to raise X to N by passing an Accumulator
%% from call to call.
%% When N is 0, return the value of the Accumulator;
%% otherwise return raise(X, N - 1, X * Accumulator)

-spec(raise(number(), integer(), number()) -&gt; number()).

raise(_, 0, Accumulator) -&gt;
  io:format("N equals 0."),
  Result = Accumulator,
  io:format("Result is ~p~n", [Result]),
  Result;

raise(X, N, Accumulator) -&gt;
  io:format("Enter: X is ~p, N is ~p, Accumulator is ~p~n",
    [X, N, Accumulator]),
  Result = raise(X, N-1, X * Accumulator),
  io:format("Result is ~p~n", [Result]),
  Result.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION04-ET05">
<h1>Solution 4-5</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH04-ET05">Étude 4-5</a>.</p>




<section class="sect2" data-type="sect2" id="__code_powers_erl_code_3">
<h2><code>powers.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for raising a number to an integer power
%% and finding the Nth root of a number using Newton's method.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(powers).
-export([nth_root/2, raise/2]).

%% @doc Find the nth root of a given number.

-spec(nth_root(number(), integer()) -&gt; number()).

nth_root(X, N) -&gt;
  A = X / 2.0,
  nth_root(X, N, A).

%% @doc Helper function to find an nth_root by passing
%% an approximation from one call to the next.
%% If the difference between current and next approximations
%% is less than 1.0e-8, return the next approximation; otherwise return
%% nth_root(X, N, NextApproximation).

nth_root(X, N, A) -&gt;
  io:format("Current guess is ~p~n", [A]), %% see the guesses converge
  F = raise(A, N) - X,
  Fprime = N * raise(A, N - 1),
  Next = A - F / Fprime,
  Change = abs(Next - A),
  if
    Change &lt; 1.0e-8 -&gt; Next;
    true -&gt; nth_root(X, N, Next)
  end.

%% @doc Raise a number X to an integer power N.
%% Any number to the power 0 equals 1.
%% Any number to the power 1 is that number itself.
%% When N is positive, X^N is equal to X times X^(N - 1)
%% When N is negative, X^N is equal to 1.0 / X^N

-spec(raise(number(), integer()) -&gt; number()).

raise(_, 0) -&gt; 1;

raise(X, N) when N &gt; 0 -&gt;
  raise(X, N, 1);

raise(X, N) when N &lt; 0 -&gt; 1 / raise(X, -N).

%% @doc Helper function to raise X to N by passing an Accumulator
%% from call to call.
%% When N is 0, return the value of the Accumulator;
%% otherwise return raise(X, N - 1, X * Accumulator)

raise(_, 0, Accumulator) -&gt; Accumulator;

raise(X, N, Accumulator) -&gt;
  raise(X, N-1, X * Accumulator).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION05-ET01">
<h1>Solution 5-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH05-ET01">Étude 5-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_geom_erl_code_9">
<h2><code>geom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating areas of geometric shapes.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(geom).
-export([area/3]).

%% @doc Calculates the area of a shape, given the
%% shape and two of the dimensions. Returns the product
%% of its arguments for a rectangle, one half the
%% product of the arguments for a triangle, and
%% math:pi times the product of the arguments for
%% an ellipse.

-spec(area(atom(), number(), number()) -&gt; number()).

area(Shape, A, B) when A &gt;= 0, B &gt;= 0 -&gt;
  case Shape of
    rectangle -&gt; A * B;
    triangle -&gt; (A * B) / 2.0;
    ellipse -&gt; math:pi() * A * B
  end.</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_ask_area_erl_code">
<h2><code>ask_area.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions to calculate areas of shape given user input.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(ask_area).
-export([area/0]).

%% @doc Requests a character for the name of a shape,
%% numbers for its dimensions, and calculates shape's area.
%% The characters are R for rectangle, T for triangle,
%% and E for ellipse. Input is allowed in either upper
%% or lower case.

-spec(area() -&gt; number()).

area() -&gt;
  Answer = io:get_line("R)ectangle, T)riangle, or E)llipse &gt; "),
  Shape = char_to_shape(hd(Answer)),
  case Shape of
    rectangle -&gt; Numbers = get_dimensions("width", "height");
    triangle -&gt; Numbers = get_dimensions("base", "height");
    ellipse -&gt; Numbers = get_dimensions("major axis", "minor axis");
    unknown -&gt; Numbers = {error, "Unknown shape " ++ [hd(Answer)]}
  end,

  Area = calculate(Shape, element(1, Numbers), element(2, Numbers)),
  Area.

%% @doc Given a character, returns an atom representing the
%% specified shape (or the atom unknown if a bad character is given).

-spec(char_to_shape(char()) -&gt; atom()).

char_to_shape(Char) -&gt;
  case Char of
    $R -&gt; rectangle;
    $r -&gt; rectangle;
    $T -&gt; triangle;
    $t -&gt; triangle;
    $E -&gt; ellipse;
    $e -&gt; ellipse;
    _ -&gt;  unknown
  end.

%% @doc Present a prompt and get a number from the
%% user. Allow either integers or floats.

-spec(get_number(string()) -&gt; number()).

get_number(Prompt) -&gt;
  Str = io:get_line("Enter " ++ Prompt ++ " &gt; "),
  {Test, _} = string:to_float(Str),
  case Test of
    error -&gt; {N, _} = string:to_integer(Str);
    _ -&gt; N = Test
  end,
  N.

%% @doc Get dimensions for a shape. Input are the two prompts,
%% output is a tuple {Dimension1, Dimension2}.

-spec(get_dimensions(string(), string()) -&gt; {number(), number()}).

get_dimensions(Prompt1, Prompt2) -&gt;
  N1 = get_number(Prompt1),
  N2 = get_number(Prompt2),
  {N1, N2}.

%% @doc Calculate area of a shape, given its shape and dimensions.
%% Handle errors appropriately.

-spec(calculate(atom(), number(), number()) -&gt; number()).

calculate(unknown, _, Err) -&gt; io:format("~s~n", [Err]);
calculate(_, error, _) -&gt; io:format("Error in first number.~n");
calculate(_, _, error) -&gt; io:format("Error in second number.~n");
calculate(_, A, B) when A &lt; 0; B &lt; 0 -&gt;
  io:format("Both numbers must be greater than or equal to zero~n");
calculate(Shape, A, B) -&gt; geom:area(Shape, A, B).


</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION05-ET02">
<h1>Solution 5-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH05-ET02">Étude 5-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_dates_erl_code">
<h2><code>dates.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for splitting a date into a list of
%% year-month-day.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(dates).
-export([date_parts/1]).

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns a list of integers in form [year, month, day].

-spec(date_parts(list()) -&gt; list()).

date_parts(DateStr) -&gt;
  [YStr, MStr, DStr] = re:split(DateStr, "-", [{return, list}]),
  [element(1, string:to_integer(YStr)),
    element(1, string:to_integer(MStr)),
    element(1, string:to_integer(DStr))].</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION06-ET01">
<h1>Solution 6-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH06-ET01">Étude 6-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_stats_erl_code">
<h2><code>stats.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating basic statistics on a list of numbers.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(stats).
-export([minimum/1]).

%% @doc Returns the minimum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(minimum(list(number())) -&gt; number()).

minimum(NumberList) -&gt;
  [Result | Rest] = NumberList,
  minimum(Rest, Result).

minimum([], Result) -&gt; Result;

minimum([Head|Tail], Result) -&gt;
  case Head &lt; Result of
    true -&gt; minimum(Tail, Head);
    false -&gt; minimum(Tail, Result)
  end.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION06-ET02">
<h1>Solution 6-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH06-ET02">Étude 6-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_stats_erl_code_2">
<h2><code>stats.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating basic statistics on a list of numbers.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(stats).
-export([minimum/1, maximum/1, range/1]).

%% @doc Returns the minimum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(minimum(list(number())) -&gt; number()).

minimum(NumberList) -&gt;
  [Result | Rest] = NumberList,
  minimum(Rest, Result).

minimum([], Result) -&gt; Result;

minimum([Head|Tail], Result) -&gt;
  case Head &lt; Result of
    true -&gt; minimum(Tail, Head);
    false -&gt; minimum(Tail, Result)
  end.

%% @doc Returns the maximum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(maximum(list(number())) -&gt; number()).

maximum(NumberList) -&gt;
  [Result | Rest] = NumberList,
  maximum(Rest, Result).

maximum([], Result) -&gt; Result;

maximum([Head|Tail], Result) -&gt;
  case Head &gt; Result of
    true -&gt; maximum(Tail, Head);
    false -&gt; maximum(Tail, Result)
  end.

%% @doc Return the range (maximum and minimum) of a list of numbers
%% as a two-element list.
-spec(range([number()]) -&gt; [number()]).

range(NumberList) -&gt; [minimum(NumberList), maximum(NumberList)].
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION06-ET03">
<h1>Solution 6-3</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH06-ET03">Étude 6-3</a> with leap years handled in the
<code>julian/5</code> function.</p>




<section class="sect2" data-type="sect2" id="__code_dates_erl_code_2">
<h2><code>dates.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for splitting a date into a list of
%% year-month-day and finding Julian date.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(dates).
-export([date_parts/1, julian/1, is_leap_year/1]).

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns a list of integers in form [year, month, day].

-spec(date_parts(string()) -&gt; list(integer())).

date_parts(DateStr) -&gt;
  [YStr, MStr, DStr] = re:split(DateStr, "-", [{return, list}]),
  [element(1, string:to_integer(YStr)),
    element(1, string:to_integer(MStr)),
    element(1, string:to_integer(DStr))].

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns the day of the year (Julian date).

-spec(julian(string()) -&gt; pos_integer()).

julian(IsoDate) -&gt;
  DaysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  [Y, M, D] = date_parts(IsoDate),
  julian(Y, M, D, DaysPerMonth, 0).

%% @doc Helper function that recursively accumulates the number of days
%% up to the specified date.

-spec(julian(integer(), integer(), integer(), [integer()], integer) -&gt; integer()).

julian(Y, M, D, MonthList, Total) when M &gt; 13 - length(MonthList) -&gt;
  [ThisMonth|RemainingMonths] = MonthList,
  julian(Y, M, D, RemainingMonths, Total + ThisMonth);

julian(Y, M, D, _MonthList, Total) -&gt;
  case M &gt; 2 andalso is_leap_year(Y) of
    true -&gt; Total + D + 1;
    false -&gt; Total + D
  end.

%% @doc Given a year, return true or false depending on whether
%% the year is a leap year.

-spec(is_leap_year(pos_integer()) -&gt; boolean()).

is_leap_year(Year) -&gt;
  (Year rem 4 == 0 andalso Year rem 100 /= 0)
    orelse (Year rem 400 == 0).
</pre>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH06-ET03">Étude 6-3</a> with leap years handled in the
<code>julian/1</code> function.</p>
</section>






<section class="sect2" data-type="sect2" id="__code_dates_erl_code_3">
<h2><code>dates.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for splitting a date into a list of
%% year-month-day and finding Julian date.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(dates).
-export([date_parts/1, julian/1, is_leap_year/1]).

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns a list of integers in form [year, month, day].

-spec(date_parts(string()) -&gt; list(integer())).

date_parts(DateStr) -&gt;
  [YStr, MStr, DStr] = re:split(DateStr, "-", [{return, list}]),
  [element(1, string:to_integer(YStr)),
    element(1, string:to_integer(MStr)),
    element(1, string:to_integer(DStr))].

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns the day of the year (Julian date).

-spec(julian(string()) -&gt; pos_integer()).

julian(IsoDate) -&gt;
  [Y, M, D] = date_parts(IsoDate),
  DaysInFeb = case is_leap_year(Y) of
    true -&gt; 29;
    _else -&gt; 28
  end,
  DaysPerMonth = [31, DaysInFeb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  julian(Y, M, D, DaysPerMonth, 0).

%% @doc Helper function that recursively accumulates the number of days
%% up to the specified date.

-spec(julian(integer(), integer(), integer(), [integer()], integer) -&gt; integer()).

julian(Y, M, D, MonthList, Total) when M &gt; 13 - length(MonthList) -&gt;
  [ThisMonth|RemainingMonths] = MonthList,
  julian(Y, M, D, RemainingMonths, Total + ThisMonth);

julian(_Y, _M, D, _MonthList, Total) -&gt;
  Total + D.

%% @doc Given a year, return true or false depending on whether
%% the year is a leap year.

-spec(is_leap_year(pos_integer()) -&gt; boolean()).

is_leap_year(Year) -&gt;
  (Year rem 4 == 0 andalso Year rem 100 /= 0)
    orelse (Year rem 400 == 0).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION06-ET04">
<h1>Solution 6-4</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH06-ET04">Étude 6-4</a>.</p>




<section class="sect2" data-type="sect2" id="__code_teeth_erl_code">
<h2><code>teeth.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Show teeth that need attention due to excessive pocket depth.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(teeth).
-export([alert/1]).

%% @doc Create a list of tooth numbers that require attention.

-spec(alert[integer()]) -&gt; [integer()]).

alert(ToothList) -&gt; alert(ToothList, 1, []).

%% @doc Helper function that accumulates the list of teeth needing attention

-spec(alert([integer()], integer(), [integer()]) -&gt; [integer()]).

alert([], _Tooth_number, Result) -&gt; lists:reverse(Result);

alert([Head | Tail ], ToothNumber, Result ) -&gt;
  case stats:maximum(Head) &gt;= 4 of
    true -&gt; alert(Tail, ToothNumber + 1, [ToothNumber | Result]);
    false -&gt; alert(Tail, ToothNumber + 1, Result)
  end.
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_stats_erl_code_3">
<h2><code>stats.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating basic statistics on a list of numbers.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(stats).
-export([minimum/1, maximum/1, range/1]).

%% @doc Returns the minimum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(minimum([number()]) -&gt; number()).

minimum(NumberList) -&gt;
  minimum(NumberList, hd(NumberList)).

minimum([], Result) -&gt; Result;

minimum([Head|Tail], Result) -&gt;
  case Head &lt; Result of
    true -&gt; minimum(Tail, Head);
    false -&gt; minimum(Tail, Result)
  end.

%% @doc Returns the maximum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(maximum([number()]) -&gt; number()).

maximum(NumberList) -&gt;
  maximum(NumberList, hd(NumberList)).

maximum([], Result) -&gt; Result;

maximum([Head|Tail], Result) -&gt;
  case Head &gt; Result of
    true -&gt; maximum(Tail, Head);
    false -&gt; maximum(Tail, Result)
  end.

%% @doc Return the range (maximum and minimum) of a list of numbers
%% as a two-element list.
-spec(range([number()]) -&gt; [number()]).

range(NumberList) -&gt; [minimum(NumberList), maximum(NumberList)].

</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION06-ET05">
<h1>Solution 6-5</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH06-ET05">Étude 6-5</a>.</p>




<section class="sect2" data-type="sect2" id="__code_non_fp_erl_code">
<h2><code>non_fp.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Generate a random set of teeth, with a certain
%% percentage expected to be bad.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(non_fp).
-export([generate_teeth/2, test_teeth/0]).

%% @doc Generate a list of lists, six numbers per tooth, giving random
%% pocket depths. Takes a string where T="there's a tooth there"
%% and F="no tooth"), and a float giving probability that a tooth is good.

-spec(generate_teeth(string(), float()) -&gt; list(list(integer()))).

generate_teeth(TeethPresent, ProbGood) -&gt;
  random:seed(now()),
  generate_teeth(TeethPresent, ProbGood, []).

%% @doc Helper function that adds tooth data to the ultimate result.

-spec(generate_teeth(string(), float(), [[integer()]]) -&gt; [[integer()]]).

generate_teeth([], _Prob, Result) -&gt; lists:reverse(Result);

generate_teeth([$F | Tail], ProbGood, Result) -&gt;
  generate_teeth(Tail, ProbGood, [[0] | Result]);

generate_teeth([$T | Tail], ProbGood, Result) -&gt;
  generate_teeth(Tail, ProbGood,
  [generate_tooth(ProbGood) | Result]).

-spec(generate_tooth(float()) -&gt; list(integer())).

%% @doc Generates a list of six numbers for a single tooth. Choose a
%% random number between 0 and 1. If that number is less than the probability
%% of a good tooth, it sets the "base depth" to 2, otherwise it sets the base
%% depth to 3.

generate_tooth(ProbGood) -&gt;
  Good = random:uniform() &lt; ProbGood,
  case Good of
    true -&gt; BaseDepth = 2;
    false -&gt; BaseDepth = 3
  end,
  generate_tooth(BaseDepth, 6, []).

%% @doc Take the base depth, add a number in range -1..1 to it,
%% and add it to the list.

generate_tooth(_Base, 0, Result) -&gt; Result;

generate_tooth(Base, N, Result) -&gt;
  [Base + random:uniform(3) - 2 | generate_tooth(Base, N - 1, Result)].

test_teeth() -&gt;
  TList = "FTTTTTTTTTTTTTTFTTTTTTTTTTTTTTTT",
  N = generate_teeth(TList, 0.75),
  print_tooth(N).

print_tooth([]) -&gt; io:format("Finished.~n");
print_tooth([H|T]) -&gt;
  io:format("~p~n", [H]),
  print_tooth(T).

</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION07-ET01">
<h1>Solution 7-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH07-ET01">Étude 7-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_calculus_erl_code">
<h2><code>calculus.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Find the derivative of a function Fn at point X.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(calculus).
-export([derivative/2]).

%% @doc Calculate derivative by classical definition.
%% (Fn(X + H) - Fn(X)) / H

-spec(derivative(function(), float()) -&gt; float()).

derivative(Fn, X) -&gt;
	Delta = 1.0e-10,
	(Fn(X + Delta) - Fn(X)) / Delta.

</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION07-ET02">
<h1>Solution 7-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH07-ET02">Étude 7-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_patmatch_erl_code">
<h2><code>patmatch.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Use pattern matching in a list comprehension.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(patmatch).
-export([older_males/0, older_or_male/0]).

%% @doc Select all males older than 40 from a list of tuples giving
%% name, gender, and age.

-spec(older_males() -&gt; list()).

get_people() -&gt;
  [{"Federico", $M, 22}, {"Kim", $F, 45}, {"Hansa", $F, 30},
  {"Vu", $M, 47}, {"Cathy", $F, 32}, {"Elias", $M, 50}].

older_males() -&gt;
  People = get_people(),
  [Name || {Name, Gender, Age} &lt;- People, Gender == $M, Age &gt; 40].

older_or_male() -&gt;
  People = get_people(),
  [Name || {Name, Gender, Age} &lt;- People, (Gender == $M) orelse (Age &gt; 40)].
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION07-ET03">
<h1>Solution 7-3</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH07-ET03">Étude 7-3</a>.</p>




<section class="sect2" data-type="sect2" id="__code_stats_erl_code_4">
<h2><code>stats.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating basic statistics on a list of numbers.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(stats).
-export([minimum/1, maximum/1, range/1, mean/1, stdv/1, stdv_sums/2]).

%% @doc Returns the minimum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(minimum(list()) -&gt; number()).

minimum(NumberList) -&gt;
  minimum(NumberList, hd(NumberList)).

minimum([], Result) -&gt; Result;

minimum([Head|Tail], Result) -&gt;
  case Head &lt; Result of
    true -&gt; minimum(Tail, Head);
    false -&gt; minimum(Tail, Result)
  end.

%% @doc Returns the maximum item in a list of numbers. Fails when given
%% an empty list, as there's nothing reasonable to return.

-spec(maximum(list()) -&gt; number()).

maximum(NumberList) -&gt;
  maximum(NumberList, hd(NumberList)).

maximum([], Result) -&gt; Result;

maximum([Head|Tail], Result) -&gt;
  case Head &gt; Result of
    true -&gt; maximum(Tail, Head);
    false -&gt; maximum(Tail, Result)
  end.

%% @doc Return the range (maximum and minimum) of a list of numbers
%% as a two-element list.
-spec(range(list()) -&gt; list()).

range(NumberList) -&gt; [minimum(NumberList), maximum(NumberList)].

%% @doc Return the mean of the list.
-spec(mean(list) -&gt; float()).

mean(NumberList) -&gt;
  Sum = lists:foldl(fun(V, A) -&gt; V + A end, 0, NumberList),
  Sum / length(NumberList).

stdv_sums(Value, Accumulator) -&gt;
  [Sum, SumSquares] = Accumulator,
  [Sum + Value, SumSquares + Value * Value].

stdv(NumberList) -&gt;
  N = length(NumberList),
  [Sum, SumSquares] = lists:foldl(fun stdv_sums/2, [0, 0], NumberList),
  math:sqrt((N * SumSquares - Sum * Sum) / (N * (N - 1))).

</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION07-ET04">
<h1>Solution 7-4</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH07-ET04">Étude 7-4</a>.</p>




<section class="sect2" data-type="sect2" id="__code_dates_erl_code_4">
<h2><code>dates.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for splitting a date into a list of
%% year-month-day and finding Julian date.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(dates).
-export([date_parts/1, julian/1, is_leap_year/1]).

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns a list of integers in form [year, month, day].

-spec(date_parts(list()) -&gt; list()).

date_parts(DateStr) -&gt;
  [YStr, MStr, DStr] = re:split(DateStr, "-", [{return, list}]),
  [element(1, string:to_integer(YStr)),
    element(1, string:to_integer(MStr)),
    element(1, string:to_integer(DStr))].

%% @doc Takes a string in ISO date format (yyyy-mm-dd) and
%% returns the day of the year (Julian date).
%% Works by summing the days per month up to, but not including,
%% the month in question, then adding the number of days.
%% If it's a leap year and past February, add a leap day.

-spec(julian(list()) -&gt; integer()).

julian(DateStr) -&gt;
  DaysPerMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  [Y, M, D] = date_parts(DateStr),
  {Sublist, _} = lists:split(M - 1, DaysPerMonth),
  Total = lists:foldl(fun(V, A) -&gt; V + A end, 0, Sublist),
  case M &gt; 2 andalso is_leap_year(Y) of
    true -&gt; Total + D + 1;
    false -&gt; Total + D
  end.

is_leap_year(Year) -&gt;
  (Year rem 4 == 0 andalso Year rem 100 /= 0)
    orelse (Year rem 400 == 0).</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION07-ET05">
<h1>Solution 7-5</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH07-ET05">Étude 7-5</a>.</p>




<section class="sect2" data-type="sect2" id="__code_cards_erl_code">
<h2><code>cards.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for playing a card game.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(cards).
-export([make_deck/0, show_deck/1]).

%% @doc generate a deck of cards
make_deck() -&gt;
  [{Value, Suit} || Value &lt;- ["A", 2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K"],
    Suit &lt;- ["Clubs", "Diamonds", "Hearts", "Spades"]].

show_deck(Deck) -&gt;
  lists:foreach(fun(Item) -&gt; io:format("~p~n", [Item]) end, Deck).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION07-ET06">
<h1>Solution 7-6</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH07-ET06">Étude 7-6</a>.</p>




<section class="sect2" data-type="sect2" id="__code_cards_erl_code_2">
<h2><code>cards.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for playing a card game.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(cards).
-export([make_deck/0, shuffle/1]).

%% @doc generate a deck of cards
make_deck() -&gt;
  [{Value, Suit} || Value &lt;- ["A", 2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K"],
    Suit &lt;- ["Clubs", "Diamonds", "Hearts", "Spades"]].

shuffle(List) -&gt; shuffle(List, []).

%% If the list is empty, return the accumulated value.
shuffle([], Acc) -&gt; Acc;

%% Otherwise, find a random location in the list and split the list
%% at that location. Let's say the list has 52 elements and the random
%% location is location 22. The first 22 elements go into Leading, and the
%% last 30 elements go into [H|T]. Thus, H would contain element 23, and
%% T would contain elements 24 through 52.
%%
%% H is the "chosen element". It goes into the accumulator (the shuffled list)
%% and then we call shuffle again with the remainder of the deck: the
%% leading elements and the tail of the split list.

shuffle(List, Acc) -&gt;
  {Leading, [H | T]} = lists:split(random:uniform(length(List)) - 1, List),
  shuffle(Leading ++ T, [H | Acc]).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION08-ET01">
<h1>Solution 8-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH08-ET01">Étude 8-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_cards_erl_code_3">
<h2><code>cards.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for playing card games.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(cards).
-export([make_deck/0, shuffle/1]).

%% @doc generate a deck of cards
-type card()::{string()|integer(), string()}.
-spec(make_deck() -&gt; [card()]).

%%make_deck() -&gt;
%%  [{Value, Suit} || Value &lt;- ["A", 2, 3, 4, 5, 6, 7, 8, 9, 10, "J", "Q", "K"],
%%    Suit &lt;- ["Clubs", "Diamonds", "Hearts", "Spades"]].

make_deck() -&gt;
  [{Value, Suit} || Value &lt;- ["A", 2, 3, 4],
    Suit &lt;- ["Clubs", "Diamonds"]].

%% Do a Fisher-Yates shuffle of a deck
-spec(shuffle([card()])-&gt; [card()]).

shuffle(List) -&gt; shuffle(List, []).

%% If the list is empty, return the accumulated value.
shuffle([], Acc) -&gt; Acc;

%% Otherwise, find a random location in the list and split the list
%% at that location. Let's say the list has 52 elements and the random
%% location is location 22. The first 22 elements go into Leading, and the
%% last 30 elements go into [H|T]. Thus, H would contain element 23, and
%% T would contain elements 24 through 52.
%%
%% H is the "chosen element". It goes into the accumulator (the shuffled list)
%% and then we call shuffle again with the remainder of the deck: the
%% leading elements and the tail of the split list.

shuffle(List, Acc) -&gt;
  {Leading, [H | T]} = lists:split(random:uniform(length(List)) - 1, List),
  shuffle(Leading ++ T, [H | Acc]).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_game_erl_code">
<h2><code>game.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Play the card game "war" with two players.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(game).
-export([play_game/0, dealer/0, player/2, value/1]).

%% @doc create a dealer
play_game() -&gt;
  spawn(game, dealer, []).

dealer() -&gt;
  random:seed(now()),
  DealerPid = self(),
  Deck = cards:shuffle(cards:make_deck()),
  {P1Cards, P2Cards} = lists:split(trunc(length(Deck) / 2), Deck),
  io:format("About to spawn players each with ~p cards.~n",
    [trunc(length(Deck) / 2)]),
  P1 = spawn(game, player, [DealerPid, P1Cards]),
  P2 = spawn(game, player, [DealerPid, P2Cards]),
  io:format("Spawned players ~p and ~p~n", [P1, P2]),
  dealer([P1, P2], pre_battle, [], [], 0, []).

%% The dealer has to keep track of the players' process IDs,
%% the cards they have given to the dealer for comparison,
%% how many players have responded (0, 1, or 2), and the pile
%% in the middle of the table in case of a war.

dealer(Pids, State, P1Cards, P2Cards, Count, Pile) -&gt;
  [P1, P2] = Pids,
  NCards = if
    Pile == []  -&gt; 1;
    Pile /= [] -&gt; 3
  end,
  case State of
    pre_battle -&gt;
      P1 ! {give_cards, NCards},
      P2 ! {give_cards, NCards},
      dealer(Pids, await_battle, P1Cards, P2Cards, Count, Pile);
    await_battle -&gt;
      receive
        {accept, Pid, Data} -&gt;
          NextCount = Count + 1,
          case Pid of
            P1 -&gt; Next_P1Cards = Data, Next_P2Cards = P2Cards;
            P2 -&gt; Next_P1Cards = P1Cards, Next_P2Cards = Data
          end
      end,
      if
        NextCount == 2 -&gt; NextState = check_cards;
        NextCount /= 2 -&gt; NextState = State
      end,
      dealer(Pids, NextState, Next_P1Cards, Next_P2Cards,
        NextCount, Pile);
    check_cards -&gt;
      Winner = game_winner(P1Cards, P2Cards),
      case Winner of
        0 -&gt;
          io:format("Compare ~p to ~p~n", [P1Cards, P2Cards]),
          NewPile = Pile ++ P1Cards ++ P2Cards,
          case battle_winner(P1Cards, P2Cards) of
             0 -&gt; dealer(Pids, pre_battle, [], [], 0, NewPile);
             1 -&gt;
              P1 ! {take_cards, NewPile},
              dealer(Pids, await_confirmation, [], [], 0, []);
             2 -&gt;
              P2 ! {take_cards, NewPile},
              dealer(Pids, await_confirmation, [], [], 0, [])
           end;
        3 -&gt;
          io:format("It's a draw!~n"),
          end_game(Pids);
        _ -&gt;
          io:format("Player ~p wins~n", [Winner]),
          end_game(Pids)
      end;
    await_war-&gt;
      io:format("Awaiting war~n");
    await_confirmation -&gt;
      io:format("Awaiting confirmation of player receiving cards~n"),
      receive
        {confirmed, _Pid, _Data} -&gt;
        dealer(Pids, pre_battle, [], [], 0, [])
      end
  end.

end_game(Pids) -&gt;
  lists:foreach(fun(Process) -&gt; exit(Process, kill) end, Pids),
  io:format("Game finished.~n").

%% Do we have a winner? If both players are out of cards,
%% it's a draw. If one player is out of cards, the other is the winner.

game_winner([], []) -&gt; 3;
game_winner([], _) -&gt; 2;
game_winner(_, []) -&gt; 1;
game_winner(_, _) -&gt; 0.

battle_winner(P1Cards, P2Cards) -&gt;
  V1 = value(hd(lists:reverse(P1Cards))),
  V2 = value(hd(lists:reverse(P2Cards))),
  Winner = if
    V1 &gt; V2 -&gt; 1;
    V2 &gt; V1 -&gt; 2;
    V1 == V2 -&gt; 0
  end,
  io:format("Winner of ~p vs. ~p is ~p~n", [V1, V2, Winner]),
  Winner = Winner.

player(Dealer, Hand) -&gt;
  receive
    {Command, Data} -&gt;
      case Command of
        give_cards -&gt;
          {ToSend, NewHand} = give_cards(Hand, Data),
          io:format("Sending ~p to ~p~n", [ToSend, Dealer]),
          Dealer!{accept, self(), ToSend};
        take_cards -&gt;
          io:format("~p now has ~p (cards)~n", [self(),
            length(Data) + length(Hand)]),
          NewHand = Hand ++ Data,
          Dealer!{confirmed, self(), []}
      end
  end,
  player(Dealer, NewHand).

%% Player gives N cards from current Hand. N is 1 or 3,
%% depending if there is a war or not.
%% If a player is asked for 3 cards but doesn't have enough,
%% give all the cards in the hand.
%% This function returns a tuple: {[cards to send], [remaining cards in hand]}

give_cards([], _N) -&gt; {[],[]};
give_cards([A], _N) -&gt; {[A],[]};
give_cards([A, B], N) -&gt;
  if
    N == 1 -&gt; {[A], [B]};
    N == 3 -&gt; {[A, B], []}
  end;
give_cards(Hand, N) -&gt;
  if
    N == 1 -&gt; {[hd(Hand)], tl(Hand)};
    N == 3 -&gt;
      [A, B, C | Remainder] = Hand,
      {[A, B, C], Remainder}
  end.

%% @doc Returns the value of a card. Aces are high; K &gt; Q &gt; J
-spec(value({cards:card()}) -&gt; integer()).

value({V, _Suit}) -&gt;
  if
    is_integer(V) -&gt; V;
    is_list(V) -&gt;
      case hd(V) of
        $J -&gt; 11;
        $Q -&gt; 12;
        $K -&gt; 13;
        $A -&gt; 14
      end
  end.</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION09-ET01">
<h1>Solution 9-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH09-ET01">Étude 9-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_stats_erl_code_5">
<h2><code>stats.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Functions for calculating basic statistics on a list of numbers.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(stats).
-export([minimum/1, maximum/1, range/1, mean/1, stdv/1, stdv_sums/2]).

%% @doc Returns the minimum item in a list of numbers. Uses
%% try/catch to return an error when there's an empty list,
%% as there's nothing reasonable to return.

-spec(minimum(list()) -&gt; number()).

minimum(NumberList) -&gt;
  try minimum(NumberList, hd(NumberList)) of
    Answer -&gt; Answer
  catch
    error:Error -&gt; {error, Error}
  end.

minimum([], Result) -&gt; Result;

minimum([Head|Tail], Result) -&gt;
  case Head &lt; Result of
    true -&gt; minimum(Tail, Head);
    false -&gt; minimum(Tail, Result)
  end.

%% @doc Returns the maximum item in a list of numbers. Catches
%% errors when given an empty list.

-spec(maximum(list()) -&gt; number()).

maximum(NumberList) -&gt;
  try
    maximum(NumberList, hd(NumberList))
  catch
    error:Error-&gt; {error, Error}
  end.

maximum([], Result) -&gt; Result;

maximum([Head|Tail], Result) -&gt;
  case Head &gt; Result of
    true -&gt; maximum(Tail, Head);
    false -&gt; maximum(Tail, Result)
  end.

%% @doc Return the range (maximum and minimum) of a list of numbers
%% as a two-element list.
-spec(range(list()) -&gt; list()).

range(NumberList) -&gt; [minimum(NumberList), maximum(NumberList)].

%% @doc Return the mean of the list.
-spec(mean(list()) -&gt; float()).

mean(NumberList) -&gt;
  try
    Sum = lists:foldl(fun(V, A) -&gt; V + A end, 0, NumberList),
    Sum / length(NumberList)
  catch
    error:Error -&gt; {error, Error}
  end.

%% @doc Helper function to generate sums and sums of squares
%% when calculating standard deviation.

-spec(stdv_sums(number(),[number()]) -&gt; [number()]).

stdv_sums(Value, Accumulator) -&gt;
  [Sum, SumSquares] = Accumulator,
  [Sum + Value, SumSquares + Value * Value].

%% @doc Calculate the standard deviation of a list of numbers.

-spec(stdv([number()]) -&gt; float()).

stdv(NumberList) -&gt;
  N = length(NumberList),
  try
    [Sum, SumSquares] = lists:foldl(fun stdv_sums/2, [0, 0], NumberList),
    math:sqrt((N * SumSquares - Sum * Sum) / (N * (N - 1)))
  catch
    error:Error -&gt; {error, Error}
  end.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION09-ET02">
<h1>Solution 9-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH09-ET02">Étude 9-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_bank_erl_code">
<h2><code>bank.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Implement a bank account that logs its transactions.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(bank).
-export([account/1]).

-spec(account(number()) -&gt; number()).

%% @doc create a client and give it a starting balance

account(Balance) -&gt;
  Input = io:get_line("D)eposit, W)ithdraw, B)alance, Q)uit: "),
  Action = hd(Input),

  case Action of
    $D -&gt;
      Amount = get_number("Amount to deposit: "),
      NewBalance = transaction(deposit, Balance, Amount);
    $W -&gt;
      Amount = get_number("Amount to withdraw: "),
      NewBalance = transaction(withdraw, Balance, Amount);
    $B -&gt;
      NewBalance = transaction(balance, Balance);
    $Q -&gt;
      NewBalance = Balance;
    _ -&gt;
      io:format("Unknown command ~c~n", [Action]),
      NewBalance = Balance
  end,
  if
    Action /= $Q -&gt;
    account(NewBalance);
    true -&gt; true
  end.


%% @doc Present a prompt and get a number from the
%% user. Allow either integers or floats.
get_number(Prompt) -&gt;
  Str = io:get_line(Prompt),
  {Test, _} = string:to_float(Str),
  case Test of
    error -&gt; {N, _} = string:to_integer(Str);
    _ -&gt; N = Test
  end,
  N.

transaction(Action, Balance, Amount) -&gt;
  case Action of
    deposit -&gt;
      if
        Amount &gt;= 10000 -&gt;
          error_logger:warning_msg("Excessive deposit ~p~n", [Amount]),
          io:format("Your deposit of $~p may be subject to hold.", [Amount]),
          io:format("Your new balance is ~p~n", [Balance + Amount]),
          NewBalance = Balance + Amount;
        Amount &lt; 0 -&gt;
          error_logger:error_msg("Negative deposit amount ~p~n", [Amount]),
          io:format("Deposits may not be less than zero."),
          NewBalance = Balance;
        Amount &gt;= 0 -&gt;
          error_logger:info_msg("Successful deposit ~p~n", [Amount]),
          NewBalance = Balance + Amount,
          io:format("Your new balance is ~p~n", [NewBalance])
      end;
    withdraw -&gt;
      if
        Amount &gt; Balance -&gt;
          error_logger:error_msg("Overdraw ~p from balance ~p~n", [Amount,
            Balance]),
          io:format("You cannot withdraw more than your current balance of ~p.~n",
            [Balance]),
          NewBalance = Balance;
        Amount &lt; 0 -&gt;
          error_logger:error_msg("Negative withdrawal amount ~p~n", [Amount]),
          io:format("Withdrawals may not be less than zero."),
          NewBalance = Balance;
        Amount &gt;= 0 -&gt;
          error_logger:info_msg("Successful withdrawal ~p~n", [Amount]),
          NewBalance = Balance - Amount,
          io:format("Your new balance is ~p~n", [NewBalance])
      end
  end,
  NewBalance.

transaction(balance, Balance) -&gt;
  error_logger:info_msg("Balance inquiry ~p~n", [Balance]),
  Balance.


</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION10-ET01">
<h1>Solution 10-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH10-ET01">Étude 10-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_phone_records_hrl_code">
<h2><code>phone_records.hrl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-record(phone_call,
  {phone_number, start_date, start_time, end_date, end_time}).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_phone_ets_erl_code">
<h2><code>phone_ets.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Read in a database of phone calls
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(phone_ets).
-export([setup/1, summary/0, summary/1]).
-include("phone_records.hrl").

%% @doc Create an ets table of phone calls from the given file name.

-spec(setup(string()) -&gt; atom()).

setup(FileName) -&gt;

  %% If the table exists, delete it
  case ets:info(call_table) of
    undefined -&gt; false;
    _ -&gt; ets:delete(call_table)
   end,

  %% and create it anew
  ets:new(call_table, [named_table, bag,
    {keypos, #phone_call.phone_number}]),

  {ResultCode, InputFile} = file:open(FileName, [read]),
  case ResultCode of
    ok -&gt; read_item(InputFile);
    _ -&gt; io:format("Error opening file: ~p~n", [InputFile])
  end.

%% Read a line from the input file, and insert its contents into
%% the call_table. This function is called recursively until end of file

-spec(read_item(file:io_device()) -&gt; atom()).

read_item(InputFile) -&gt;
  RawData = io:get_line(InputFile, ""),
  if
    is_list(RawData) -&gt;
      Data = string:strip(RawData, right, $\n),
      [Number, SDate, STime, EDate, ETime] =
        re:split(Data, ",", [{return, list}]),
      ets:insert(call_table, #phone_call{phone_number = Number,
        start_date = to_date(SDate), start_time = to_time(STime),
        end_date = to_date(EDate), end_time= to_time(ETime)}),
      read_item(InputFile);
    RawData == eof -&gt; ok
  end.

%% @doc Convert a string in form "yyyy-mm-dd" to a tuple {yyyy, mm, dd}
%% suitable for use with the calendar module.

-spec(to_date(string()) -&gt; {integer(), integer(), integer()}).

to_date(Date) -&gt;
  [Year, Month, Day] = re:split(Date, "-", [{return, list}]),
  [{Y, _}, {M, _}, {D, _}] = lists:map(fun string:to_integer/1,
    [Year, Month, Day]),
  {Y, M, D}.

%% @doc Convert a string in form "hh:mm:ss" to a tuple {hh, mm, ss}
%% suitable for use with the calendar module.

-spec(to_time(string()) -&gt; {integer(), integer(), integer()}).

to_time(Time) -&gt;
  [Hour, Minute, Second] = re:split(Time, ":", [{return, list}]),
  [{H, _}, {M, _}, {S, _}] = lists:map(fun string:to_integer/1,
    [Hour, Minute, Second]),
  {H, M, S}.

%% @doc Create a summary of number of minutes used by all phone numbers.

-spec(summary() -&gt; [tuple(string(), integer())]).

summary() -&gt;
  FirstKey = ets:first(call_table),
  summary(FirstKey, []).

summary(Key, Result) -&gt;
  NextKey = ets:next(call_table, Key),
  case NextKey of
    '$end_of_table' -&gt; Result;
    _ -&gt; summary(NextKey, [hd(summary(Key)) | Result])
  end.

%% @doc Create a summary of number of minutes used by one phone number.

-spec(summary(string()) -&gt; [tuple(string(), integer())]).

summary(PhoneNumber) -&gt;
  Calls = ets:lookup(call_table, PhoneNumber),
  Total = lists:foldl(fun subtotal/2, 0, Calls),
  [{PhoneNumber, Total}].

subtotal(Item, Accumulator) -&gt;
  StartSeconds = calendar:datetime_to_gregorian_seconds(
    {Item#phone_call.start_date, Item#phone_call.start_time}),
  EndSeconds = calendar:datetime_to_gregorian_seconds(
    {Item#phone_call.end_date, Item#phone_call.end_time}),
  Accumulator + ((EndSeconds - StartSeconds + 59) div 60).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_generate_calls_erl_code">
<h2><code>generate_calls.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Generate a random set of data for phone calls
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(generate_calls).
-export([make_call_list/1, format_date/1, format_time/1]).

make_call_list(N) -&gt;
  Now = calendar:datetime_to_gregorian_seconds({{2013, 3, 10}, {9, 0, 0}}),
  Numbers = [
    {"213-555-0172", Now},
    {"301-555-0433", Now},
    {"415-555-7871", Now},
    {"650-555-3326", Now},
    {"729-555-8855", Now},
    {"838-555-1099", Now},
    {"946-555-9760", Now}
  ],
  CallList = make_call_list(N, Numbers, []),
  {Result, OutputFile} = file:open("call_list.csv", [write]),
  case Result of
    ok -&gt; write_item(OutputFile, CallList);
    error -&gt; io:format("Error: ~p~n", OutputFile)
  end.

make_call_list(0, _Numbers, Result) -&gt; lists:reverse(Result);

make_call_list(N, Numbers, Result) -&gt;
  Entry = random:uniform(length(Numbers)),
  {Head, Tail} = lists:split(Entry - 1, Numbers),
  {Number, LastCall} = hd(Tail),
  StartCall = LastCall + random:uniform(120) + 20,
  Duration = random:uniform(180) + 40,
  EndCall = StartCall + Duration,
  Item = [Number, format_date(StartCall), format_time(StartCall),
    format_date(EndCall), format_time(EndCall)],
  UpdatedNumbers = Head ++ [{Number, EndCall} | tl(Tail)],
  make_call_list(N - 1, UpdatedNumbers, [Item | Result]).

write_item(OutputFile, []) -&gt;
  file:close(OutputFile);

write_item(OutputFile, [H|T]) -&gt;
  io:format("~s ~s ~s ~s ~s~n", H),
  io:fwrite(OutputFile, "~s,~s,~s,~s,~s~n", H),
  write_item(OutputFile, T).

format_date(GSeconds) -&gt;
  {Date, _Time} = calendar:gregorian_seconds_to_datetime(GSeconds),
  {Y, M, D} = Date,
  lists:flatten(io_lib:format("~4b-~2..0b-~2..0b", [Y, M, D])).

format_time(GSeconds) -&gt;
  {_Date, Time} = calendar:gregorian_seconds_to_datetime(GSeconds),
  {M, H, S} = Time,
  lists:flatten(io_lib:format("~2..0b:~2..0b:~2..0b", [M, H, S])).
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION10-ET02">
<h1>Solution 10-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH10-ET02">Étude 10-2</a>.</p>




<section class="sect2" data-type="sect2" id="__code_phone_records_hrl_code_2">
<h2><code>phone_records.hrl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-record(phone_call,
  {phone_number, start_date, start_time, end_date, end_time}).
-record(customer,
  {phone_number, last_name, first_name, middle_name, rate}).</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_phone_mnesia_erl_code">
<h2><code>phone_mnesia.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Read in a database of phone calls and customers.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(phone_mnesia).
-export([setup/2, summary/3]).
-include("phone_records.hrl").
-include_lib("stdlib/include/qlc.hrl").

%% @doc Set up Mnesia tables for phone calls and customers
%% given their file names

-spec(setup(string(), string()) -&gt; atom()).

setup(CallFileName, CustomerFileName) -&gt;

  mnesia:create_schema([node()]),
  mnesia:start(),
  mnesia:delete_table(phone_call),
  mnesia:delete_table(customer),

  fill_table(phone_call, CallFileName, fun add_call/1,
    record_info(fields, phone_call), bag),
  fill_table(customer, CustomerFileName, fun add_customer/1,
    record_info(fields, customer), set).

%% @doc Fill the given table with data from given file name.
%% AdderFunction assigns data to fields and writes it to the table;
%% RecordInfo is used when creating the table, as is the TableType.

fill_table(TableName, FileName, AdderFunction, RecordInfo, TableType) -&gt;
  mnesia:create_table(TableName, [{attributes, RecordInfo}, {type, TableType}]),

  {OpenResult, InputFile} = file:open(FileName, [read]),
  case OpenResult of
    ok -&gt;
      mnesia:transaction(
        fun() -&gt; read_file(InputFile, AdderFunction) end);
    _ -&gt; io:format("Error opening file: ~p~n", [FileName])
  end.

%% @doc Read a line from InputFile, and insert its contents into
%% the appropriate table by using AdderFunction.

-spec(read_file(file:io_device(), function()) -&gt; atom()).

read_file(InputFile, AdderFunction) -&gt;
  RawData = io:get_line(InputFile, ""),
  if
    is_list(RawData) -&gt;
      Data = string:strip(RawData, right, $\n),
      ItemList = re:split(Data, ",", [{return, list}]),
      AdderFunction(ItemList),
      read_file(InputFile, AdderFunction);
    RawData == eof -&gt; ok
  end.


%% Add a phone call record; the data is in an ItemList.

-spec(add_call(list()) -&gt; undefined).

add_call(ItemList) -&gt;
  [Number, SDate, STime, EDate, ETime] = ItemList,
  mnesia:write(#phone_call{phone_number = Number,
        start_date = to_date(SDate), start_time = to_time(STime),
        end_date = to_date(EDate), end_time= to_time(ETime)}).

%% Add a customer record; the data is in an ItemList.

-spec(add_customer(list()) -&gt; undefined).

add_customer(ItemList) -&gt;
  [Phone, Last, First, Middle, Rate] = ItemList,
  mnesia:write(#customer{phone_number = Phone, last_name = Last,
    first_name = First, middle_name = Middle, rate = to_float(Rate)}).

%% @doc Convert a string in form "yyyy-mm-dd" to a tuple {yyyy, mm, dd}
%% suitable for use with the calendar module.

-spec(to_date(string()) -&gt; {integer(), integer(), integer()}).

to_date(Date) -&gt;
  [Year, Month, Day] = re:split(Date, "-", [{return, list}]),
  [{Y, _}, {M, _}, {D, _}] = lists:map(fun string:to_integer/1,
    [Year, Month, Day]),
  {Y, M, D}.

%% @doc Convert a string in form "hh:mm:ss" to a tuple {hh, mm, ss}
%% suitable for use with the calendar module.

-spec(to_time(string()) -&gt; {integer(), integer(), integer()}).

to_time(Time) -&gt;
  [Hour, Minute, Second] = re:split(Time, ":", [{return, list}]),
  [{H, _}, {M, _}, {S, _}] = lists:map(fun string:to_integer/1,
    [Hour, Minute, Second]),
  {H, M, S}.


%% @doc Convenience routine to convert a string to float.
%% In case of an error, return zero.

-spec(to_float(string()) -&gt; float()).

to_float(Str) -&gt;
  {FPart, _} = string:to_float(Str),
  case FPart of
    error -&gt; 0;
    _ -&gt; FPart
  end.

summary(Last, First, Middle) -&gt;

  QHandle = qlc:q([Customer ||
    Customer &lt;- mnesia:table(customer),
    Customer#customer.last_name == Last,
    Customer#customer.first_name == First,
    Customer#customer.middle_name == Middle ]),

  {_Result, [ThePerson|_]} =
    mnesia:transaction(fun() -&gt; qlc:e(QHandle) end),

  {_Result, Calls} = mnesia:transaction(
    fun() -&gt;
       qlc:e(
        qlc:q( [Call ||
          Call &lt;- mnesia:table(phone_call),
          QCustomer &lt;- QHandle,
          QCustomer#customer.phone_number == Call#phone_call.phone_number
        ]
        )
      )
    end
  ),

  TotalMinutes = lists:foldl(fun subtotal/2, 0, Calls),

  [{ThePerson#customer.phone_number,
    TotalMinutes, TotalMinutes * ThePerson#customer.rate}].

subtotal(Item, Accumulator) -&gt;
  StartSeconds = calendar:datetime_to_gregorian_seconds(
    {Item#phone_call.start_date, Item#phone_call.start_time}),
  EndSeconds = calendar:datetime_to_gregorian_seconds(
    {Item#phone_call.end_date, Item#phone_call.end_time}),
  Accumulator + ((EndSeconds - StartSeconds + 59) div 60).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_pet_records_hrl_code">
<h2><code>pet_records.hrl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-record(person,
  {id_number, name, age, gender, city, amount_owed}).
-record(animal,
  {id_number, name, species, gender, owner_id}).
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_pet_mnesia_erl_code">
<h2><code>pet_mnesia.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @author J D Eisenberg &lt;jdavid.eisenberg@gmail.com&gt;
%% @doc Read in a database of people and their pets
%% appointments.
%% @copyright 2013 J D Eisenberg
%% @version 0.1

-module(pet_mnesia).
-export([setup/2, get_info/0, get_info_easier/0]).
-include("pet_records.hrl").
-include_lib("stdlib/include/qlc.hrl").

%% @doc Set up Mnesia tables for phone calls and customers
%% given their file names

-spec(setup(string(), string()) -&gt; atom()).

setup(PersonFileName, AnimalFileName) -&gt;

  mnesia:create_schema([node()]),
  mnesia:start(),
  mnesia:delete_table(person),
  mnesia:delete_table(animal),

  fill_table(person, PersonFileName, fun add_person/1,
    record_info(fields, person), set),
  fill_table(animal, AnimalFileName, fun add_animal/1,
    record_info(fields, animal), set).

%% @doc Fill the given table with data from given file name.
%% AdderFunction assigns data to fields and writes it to the table;
%% RecordInfo is used when creating the table, as is the TableType.

fill_table(TableName, FileName, AdderFunction, RecordInfo, TableType) -&gt;
  mnesia:create_table(TableName, [{attributes, RecordInfo}, {type, TableType}]),

  {OpenResult, InputFile} = file:open(FileName, [read]),
  case OpenResult of
    ok -&gt;
      TransResult = mnesia:transaction(
        fun() -&gt; read_file(InputFile, AdderFunction) end),
        io:format("Transaction result ~p~n", [TransResult]);
    _ -&gt; io:format("Error opening file: ~p~n", [FileName])
  end.

%% @doc Read a line from InputFile, and insert its contents into
%% the appropriate table by using AdderFunction.

-spec(read_file(file:io_device(), function()) -&gt; atom()).

read_file(InputFile, AdderFunction) -&gt;
  RawData = io:get_line(InputFile, ""),
  if
    is_list(RawData) -&gt;
      Data = string:strip(RawData, right, $\n),
      ItemList = re:split(Data, ",", [{return, list}]),
      AdderFunction(ItemList),
      read_file(InputFile, AdderFunction);
    RawData == eof -&gt; ok
  end.


%% Add a person record; the data is in an ItemList.

-spec(add_person(list()) -&gt; undefined).

add_person(ItemList) -&gt;
  [Id, Name, Age, Gender, City, Owed] = ItemList,
  mnesia:write(#person{id_number = to_int(Id), name = Name,
    age = to_int(Age), gender = Gender, city = City,
    amount_owed = to_float(Owed)}).

%% Add an animal record; the data is in an ItemList.

-spec(add_animal(list()) -&gt; undefined).

add_animal(ItemList) -&gt;
  [Id, Name, Species, Gender, Owner] = ItemList,
  mnesia:write(#animal{id_number = to_int(Id),
    name = Name, species = Species, gender = Gender,
    owner_id = to_int(Owner)}).

%% @doc Convenience routine to convert a string to integer.
%% In case of an error, return zero.

-spec(to_int(string()) -&gt; integer()).

to_int(Str) -&gt;
  {IPart, _} = string:to_integer(Str),
  case IPart of
    error -&gt; 0;
    _ -&gt; IPart
  end.

%% @doc Convenience routine to convert a string to float.
%% In case of an error, return zero.

-spec(to_float(string()) -&gt; float()).

to_float(Str) -&gt;
  {FPart, _} = string:to_float(Str),
  case FPart of
    error -&gt; 0;
    _ -&gt; FPart
  end.

get_info() -&gt;
  People = mnesia:transaction(
    fun() -&gt; qlc:e(
      qlc:q( [ P ||
        P &lt;- mnesia:table(person),
        P#person.age &gt;= 21,
        P#person.gender == "M",
        P#person.city == "Podunk"]
        )
      )
    end
  ),

  Pets = mnesia:transaction(
    fun() -&gt; qlc:e(
      qlc:q( [{A#animal.name, A#animal.species, P#person.name} ||
        P &lt;- mnesia:table(person),
        P#person.age &gt;= 21,
        P#person.gender == "M",
        P#person.city == "Podunk",
        A &lt;- mnesia:table(animal),
        A#animal.owner_id == P#person.id_number])
      )
    end
  ),
  [People, Pets].

get_info_easier() -&gt;

  %% "Pre-process" the list comprehension for finding people

  QHandle = qlc:q( [ P ||
    P &lt;- mnesia:table(person),
    P#person.age &gt;= 21,
    P#person.gender == "M",
    P#person.city == "Podunk"]
  ),

  %% Evaluate it to retrieve the people you want

  People = mnesia:transaction(
    fun() -&gt; qlc:e( QHandle ) end
  ),

  %% And use the handle again when retrieving
  %% information about their pets

  Pets = mnesia:transaction(
    fun() -&gt; qlc:e(
      qlc:q( [{A#animal.name, A#animal.species, P#person.name} ||
        P &lt;- QHandle,
        A &lt;- mnesia:table(animal),
        A#animal.owner_id == P#person.id_number])
      )
    end
  ),
  [People, Pets].


</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION11-ET01">
<h1>Solution 11-1</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH11-ET01">Étude 11-1</a>.</p>




<section class="sect2" data-type="sect2" id="__code_weather_erl_code">
<h2><code>weather.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(weather).
-behaviour(gen_server).
-include_lib("xmerl/include/xmerl.hrl").
-export([start_link/0]). % convenience call for startup
-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]). % gen_server callbacks
-define(SERVER, ?MODULE). % macro that just defines this module as server

%%% convenience method for startup
start_link() -&gt;
        gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).

%%% gen_server callbacks
init([]) -&gt;
  inets:start(),
  {ok, []}.

handle_call(Request, _From, State) -&gt;
  {Reply, NewState} = get_weather(Request, State),
  {reply, Reply, NewState}.

handle_cast(_Message, State) -&gt;
  io:format("Most recent requests: ~p\n", [State]),
  {noreply, State}.

handle_info(_Info, State) -&gt;
  {noreply, State}.

terminate(_Reason, _State) -&gt;
  inets:stop(),
  ok.

code_change(_OldVsn, State, _Extra) -&gt;
  {ok, State}.

%%% Internal functions

%% Given a 4-letter station code as the Request, return its basic
%% weather information as a {key,value} list. If successful, add the
%% station name to the State, which will keep track of recently-accessed
%% weather stations.

get_weather(Request, State) -&gt;
  URL = "http://w1.weather.gov/xml/current_obs/" ++ Request ++ ".xml",
  {Result, Info} = httpc:request(URL),
  case Result of
    error -&gt; {{Result, Info}, State};
    ok -&gt;
      {{_Protocol, Code, _CodeStr}, _Attrs, WebData} = Info,
      case Code of
        404 -&gt;
          {{error, 404}, State};
        200 -&gt;
          Weather = analyze_info(WebData),
          {{ok, Weather}, [Request | lists:sublist(State, 10)]}
      end
  end.

%% Take raw XML data and return a set of {key, value} tuples

analyze_info(WebData) -&gt;
  %% list of fields that you want to extract
  ToFind = [location, observation_time_rfc822, weather, temperature_string],

  %% get just the parsed data from the XML parse result
  Parsed = element(1, xmerl_scan:string(WebData)),

  %% This is the list of all children under &lt;current_observation&gt;
  Children = Parsed#xmlElement.content,

  %% Find only XML elements and extract their names and their text content.
  %% You need the guard so that you don't process the newlines in the
  %% data (they are XML text descendants of the root element).
  ElementList = [{El#xmlElement.name, extract_text(El#xmlElement.content)}
    || El &lt;- Children, element(1, El) == xmlElement],

  %% ElementList is now a keymap; get the data you want from it.
  lists:map(fun(Item) -&gt; lists:keyfind(Item, 1, ElementList) end, ToFind).


%% Given the parsed content of an XML element, return its first node value
%% (if it's a text node); otherwise return the empty string.

extract_text(Content) -&gt;
  Item = hd(Content),
  case element(1, Item) of
    xmlText -&gt; Item#xmlText.value;
    _ -&gt; ""
  end.

</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_weather_sup_erl_code">
<h2><code>weather_sup.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(weather_sup).
-behaviour(supervisor).
-export([start_link/0]). % convenience call for startup

-export([init/1]). % supervisor calls
-define(SERVER, ?MODULE).


%%% convenience method for startup
start_link() -&gt;
  supervisor:start_link({local, ?SERVER}, ?MODULE, []).

%%% supervisor callback
init([]) -&gt;
    RestartStrategy = one_for_one,
    MaxRestarts = 1, % one restart every
    MaxSecondsBetweenRestarts = 5, % five seconds

    SupFlags = {RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts},

    Restart = permanent, % or temporary, or transient
    Shutdown = 2000, % milliseconds, could be infinity or brutal_kill
    Type = worker, % could also be supervisor

    Weather = {weather, {weather, start_link, []},
                      Restart, Shutdown, Type, [weather]},

    {ok, {SupFlags, [Weather]}}.
</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION11-ET02">
<h1>Solution 11-2</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH11-ET02">Étude 11-2</a>. Since the bulk of the code
is identical to the code in the previous étude,
the only code shown here is the revised <code>-export</code> list
and the added functions.</p>




<section class="sect2" data-type="sect2" id="__code_weather_erl_code_2">
<h2><code>weather.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-export([report/1, recent/0]). % wrapper functions

%% Wrapper to hide internal details when getting a weather report
report(Station) -&gt;
  gen_server:call(?SERVER, Station).

%% Wrapper to hide internal details when getting a list of recently used
%% stations.
recent() -&gt;
  gen_server:cast(?SERVER, "").</pre>
</section>


</section>






<section class="sect1" data-type="sect1" id="SOLUTION11-ET03">
<h1>Solution 11-3</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH11-ET03">Étude 11-3</a>. Since the bulk of the code
is identical to the previous étude,
the only code shown here is the added and revised code.</p>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">%% @doc Connect to a named server
connect(ServerName) -&gt;
  Result = net_adm:ping(ServerName),
  case Result of
    pong -&gt; io:format("Connected to server.~n");
    pang -&gt; io:format("Cannot connect to ~p.~n", [ServerName])
  end.

%% Wrapper to hide internal details when getting a weather report
report(Station) -&gt;
  gen_server:call({global, weather}, Station).

%% Wrapper to hide internal details when getting a list of recently used
%% stations.
recent() -&gt;
  gen_server:call({global,weather}, recent).

%%% convenience method for startup
start_link() -&gt;
  gen_server:start_link({global, ?SERVER}, ?MODULE, [], []).

%%% gen_server callbacks
init([]) -&gt;
  inets:start(),
  {ok, []}.

handle_call(recent, _From, State) -&gt;
  {reply, State, State};
handle_call(Request, _From, State) -&gt;
  {Reply, NewState} = get_weather(Request, State),
  {reply, Reply, NewState}.

handle_cast(_Message, State) -&gt;
  io:format("Most recent requests: ~p\n", [State]),
  {noreply, State}.</pre>
</section>






<section class="sect1" data-type="sect1" id="SOLUTION11-ET04">
<h1>Solution 11-4</h1>
<p>Here is a suggested solution for
<a data-type="xref" href="#CH11-ET04">Étude 11-4</a>.</p>




<section class="sect2" data-type="sect2" id="__code_chatroom_erl_code">
<h2><code>chatroom.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(chatroom).
-behaviour(gen_server).
-export([start_link/0]). % convenience call for startup
-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]). % gen_server callbacks

-define(SERVER, ?MODULE). % macro that defines this module as the server

% The server state consists of a list of tuples for each person in chat.
% Each tuple has the format {{UserName, UserServer}, PID of person}

%%% convenience method for startup
start_link() -&gt;
  gen_server:start_link({local, ?SERVER}, ?MODULE, [], []).

%%% gen_server callbacks
init([]) -&gt;
  {ok, []}.

%% Check to see if a user name/server pair is unique;
%% if so, add it to the server's state

handle_call({login, UserName, ServerRef}, From, State) -&gt;
  {FromPid, _FromTag} = From,
  case lists:keymember({UserName, ServerRef}, 1, State) of
    true -&gt;
      NewState = State,
      Reply = {error, "User " ++ UserName ++ " already in use."};
    false -&gt;
      NewState = [{{UserName, ServerRef}, FromPid} | State],
      Reply = {ok, "Logged in."}
  end,
  {reply, Reply, NewState};

%% Log out the person sending the message, but only
%% if they're logged in already.

handle_call(logout, From, State) -&gt;
  {FromPid, _FromTag} = From,
  case lists:keymember(FromPid, 2, State) of
    true -&gt;
      NewState = lists:keydelete(FromPid, 2, State),
      Reply  = {ok, logged_out};
    false -&gt;
      NewState = State,
      Reply = {error, not_logged_in}
  end,
  {reply, Reply, NewState};

%% When receiving a message from a person, use the From PID to
%% get the user's name and server name from the chatroom server state.
%% Send the message via a "cast" to everyone who is NOT the sender.

handle_call({say, Text}, From, State) -&gt;
  {FromPid, _FromTag} = From,

  case lists:keymember(FromPid, 2, State) of
    true -&gt;
    {value, {{SenderName, SenderServer}, _}} =
      lists:keysearch(FromPid, 2, State),

    % For debugging: get the list of recipients.
    RecipientList = [{RecipientName, RecipientServer} ||
      {{RecipientName, RecipientServer}, _} &lt;- State,
      {RecipientName, RecipientServer} /= {SenderName, SenderServer}],
    io:format("Recipient list: ~p~n", [RecipientList]),

    [gen_server:cast({person, RecipientServer},
      {message, {SenderName, SenderServer}, Text}) ||
      {{RecipientName, RecipientServer}, _} &lt;- State,
     RecipientName /= SenderName];

    false -&gt; ok
  end,
  {reply, ok, State};

%% Get the state of another person and return it to the asker

handle_call({who, Person, ServerRef}, _From, State) -&gt;
  % Find pid of the person at the serverref
  Found = lists:keyfind({Person, ServerRef}, 1, State),

  case Found of
    {{_FromUser, _FromServer}, Pid} -&gt;
      Reply = gen_server:call(Pid, get_profile);
    _ -&gt;
      Reply = "Cannot find that user"
  end,
  {reply, Reply, State};

%% Return a list of all users currently in the chat room

handle_call(users, _From, State) -&gt;
  UserList = [{UserName, UserServer} ||
    {{UserName, UserServer}, _} &lt;- State],
  {reply, UserList, State};

handle_call(Request, _From, State) -&gt;
  {ok, {error, "Unhandled Request", Request}, State}.

handle_cast(_Request, State) -&gt;
  {noreply, State}.

handle_info(Info, State) -&gt;
  io:format("Received unknown message ~p~n", [Info]),
  {noreply, State}.

terminate(_Reason, _State) -&gt;
  ok.

code_change(_OldVsn, State, _Extra) -&gt;
  {ok, State}.

%%% Internal functions
</pre>
</section>






<section class="sect2" data-type="sect2" id="__code_person_erl_code">
<h2><code>person.erl</code></h2>
<pre data-type="programlisting" class="programlisting" data-code-language="erlang">-module(person).
-behaviour(gen_server).
-export([start_link/1]). % convenience call for startup
-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]). % gen_server callbacks

-record(state, {chat_node, profile}).

% internal functions
-export([login/1, logout/0, say/1, users/0, who/2, set_profile/2]).

-define(CLIENT, ?MODULE). % macro that defines this module as the client

%%% convenience method for startup
start_link(ChatNode) -&gt;
  gen_server:start_link({local, ?CLIENT}, ?MODULE, ChatNode, []).

init(ChatNode)-&gt;
  io:format("Chat node is: ~p~n", [ChatNode]),
  {ok, #state{chat_node=ChatNode, profile=[]}}.

%% The server is asked to either:
%% a) return the chat host name from the state,
%% b) return the user profile
%% c) update the user profile
%% d) log a user in
%% e) send a message to all people in chat room
%% f) log a user out

handle_call(get_chat_node, _From, State) -&gt;
  {reply, State#state.chat_node, State};

handle_call(get_profile, _From, State) -&gt;
  {reply, State#state.profile, State};

handle_call({set_profile, Key, Value}, _From, State) -&gt;
  case lists:keymember(Key, 1, State#state.profile) of
    true -&gt; NewProfile = lists:keyreplace(Key, 1, State#state.profile,
      {Key, Value});
    false -&gt; NewProfile = [{Key, Value} | State#state.profile]
  end,
  {reply, NewProfile,
    #state{chat_node = State#state.chat_node, profile=NewProfile}};

handle_call({login, UserName}, _From, State) -&gt;
  Reply = gen_server:call({chatroom, State#state.chat_node},
    {login, UserName, node()}),
  {reply, Reply, State};

handle_call({say, Text}, _From, State) -&gt;
  Reply = gen_server:call({chatroom, State#state.chat_node},
    {say, Text}),
  {reply, Reply, State};

handle_call(logout, _From, State) -&gt;
  Reply = gen_server:call({chatroom, State#state.chat_node}, logout),
  {reply, Reply, State};

handle_call(_, _From, State) -&gt; {ok, [], State}.

handle_cast({message, {FromUser, FromServer}, Text}, State) -&gt;
  io:format("~s (~p) says: ~p~n", [FromUser, FromServer, Text]),
  {noreply, State};

handle_cast(_Request, State) -&gt;
  io:format("Unknown request ~p~n", _Request),
  {noReply, State}.

handle_info(Info, State) -&gt;
  io:format("Received unexpected message: ~p~n", [Info]),
  {noreply, State}.

terminate(_Reason, _State) -&gt;
  ok.

code_change(_OldVsn, State, _Extra) -&gt;
  {ok, State}.


% internal functions

%% @doc Gets the name of the chat host. This is a really
%% ugly hack; it works by sending itself a call to retrieve
%% the chat node name from the server state.

get_chat_node() -&gt;
  gen_server:call(person, get_chat_node).

%% @doc Login to a server using a name
%% If you connect, tell the server your user name and node.
%% You don't need a reply from the server for this.

-spec(login(string()) -&gt; term()).

login(UserName) -&gt;
  if
    is_atom(UserName) -&gt;
      gen_server:call(?CLIENT,
        {login, atom_to_list(UserName)});
    is_list(UserName) -&gt;
      gen_server:call(?CLIENT,
        {login, UserName});
    true -&gt;
      {error, "User name must be an atom or a list"}
  end.


%% @doc Log out of the system. The person server will send a From that tells
%% who is logging out; the chatroom server doesn't need to reply.

-spec(logout() -&gt; atom()).

logout() -&gt;
  gen_server:call(?CLIENT, logout),
  ok.


%% @doc Send the given Text to the chat room server. No reply needed.

-spec(say(string()) -&gt; atom()).

say(Text) -&gt;
  gen_server:call(?CLIENT, {say, Text}),
  ok.

%% @doc Ask chat room server for a list of users.

-spec(users() -&gt; [string()]).

users() -&gt;
  gen_server:call({chatroom, get_chat_node()}, users).

%% @doc Ask chat room server for a profile of a given person.

-spec(who(string(), atom()) -&gt; [tuple()]).

who(Person, ServerRef) -&gt;
  gen_server:call({chatroom, get_chat_node()},
    {who, Person, ServerRef}).

%% @doc Update profile with a key/value pair.

-spec(set_profile(atom(), term()) -&gt; term()).

set_profile(Key, Value) -&gt;
  % ask *this* server for the current state
  NewProfile = gen_server:call(?CLIENT, {set_profile, Key, Value}),
  {ok, NewProfile}.</pre>
</section>


</section>



</section>





</body>
</html>